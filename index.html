<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shadow Monarch</title>
  <link rel="icon" href="https://upload.wikimedia.org/wikipedia/en/2/23/Solo_Leveling_logo.png" type="image/png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: url('https://wallpapercave.com/wp/wp9420280.jpg') no-repeat center center fixed;
      background-size: cover;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: -1;
    }
    .flash { animation: flashEffect 1s ease-in-out; }
    @keyframes flashEffect {
      0% { background-color: rgba(255,255,255,0.4); }
      100% { background-color: transparent; }
    }

  </style>

<style>

  @keyframes fadeIn {
  from { opacity: 0; transform: scale(0.97); }
  to { opacity: 1; transform: scale(1); }
}
.animate-fadeIn { animation: fadeIn .22s ease-out both; }
  @keyframes fadeIn {
  from { opacity: 0; transform: translateY(8px) scale(.98); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
.animate-fadeIn { animation: fadeIn .28s ease-out both; }
@keyframes fly1 {
  0%   { top: 0%; left: 50%; transform: rotate(0deg); }
  25%  { top: 20%; left: 90%; transform: rotate(90deg); }
  50%  { top: 80%; left: 60%; transform: rotate(180deg); }
  75%  { top: 40%; left: 10%; transform: rotate(270deg); }
  100% { top: 0%; left: 50%; transform: rotate(360deg); }
}

@keyframes fly2 {
  0%   { top: 80%; left: 20%; transform: rotate(0deg); }
  25%  { top: 10%; left: 80%; transform: rotate(120deg); }
  50%  { top: 60%; left: 90%; transform: rotate(240deg); }
  75%  { top: 30%; left: 30%; transform: rotate(300deg); }
  100% { top: 80%; left: 20%; transform: rotate(360deg); }
}

@keyframes fly3 {
  0%   { top: 50%; left: 100%; transform: rotate(0deg); }
  25%  { top: 90%; left: 50%; transform: rotate(180deg); }
  50%  { top: 50%; left: 0%; transform: rotate(270deg); }
  75%  { top: 10%; left: 40%; transform: rotate(360deg); }
  100% { top: 50%; left: 100%; transform: rotate(720deg); }
}
</style>
<style>

.daily-reflection-card {
  background: rgba(0,0,0,0.6);
  border: 1px solid #333;
  padding: 20px;
  border-radius: 14px;
  margin-top: 20px;
  backdrop-filter: blur(4px);
}

.dr-title {
  color: #fff;
  margin-bottom: 15px;
  font-size: 1.3rem;
  font-weight: 600;
}
.chat-box {
  background: #1b1b1b;
  border: 1px solid #333;
  padding: 14px;
  border-radius: 12px;
  margin-bottom: 18px;
}

.chat-input {
  width: 100%;
  height: 120px;
  background: transparent;
  border: none;
  color: #f2f2f2;
  font-size: 1rem;
  line-height: 1.5;
  resize: vertical;
  outline: none;

  /* FINAL RTL KILLER */
  direction: ltr !important;
  text-align: left !important;
  }


.complete-btn {
  width: 100%;
  padding: 12px;
  background: #4caf50;
  border: none;
  border-radius: 10px;
  color: white;
  font-size: 1rem;
  cursor: pointer;
}

.complete-btn:disabled {
  background: #2d2d2d;
  cursor: not-allowed;
}
  @keyframes premiumGlow {
  0% {
    filter: drop-shadow(0 0 6px var(--badge-color)) 
            drop-shadow(0 0 12px var(--badge-color));
    transform: scale(1);
  }
  50% {
    filter: drop-shadow(0 0 14px var(--badge-color)) 
            drop-shadow(0 0 28px var(--badge-color));
    transform: scale(1.1);
  }
  100% {
    filter: drop-shadow(0 0 6px var(--badge-color)) 
            drop-shadow(0 0 12px var(--badge-color));
    transform: scale(1);
  }
}

.badge {
  animation: premiumGlow 2.5s infinite ease-in-out;
  border-radius: 50%;
  transition: transform 0.3s ease;
}

</style>
<style>
@keyframes auraPulse {
  0%, 100% { box-shadow: 0 0 15px var(--aura-color), 0 0 30px var(--aura-color); }
  50% { box-shadow: 0 0 30px var(--aura-color), 0 0 60px var(--aura-color); }
}

.aura {
  animation: auraPulse 3s infinite alternate;
  border-radius: 9999px;
}
  </style>
  <style>
@keyframes slowGlow {
  0%, 100% { filter: drop-shadow(0 0 3px #ff0000); }
  50% { filter: drop-shadow(0 0 15px #ff1a1a); }
}

.slow-glow {
  animation: slowGlow 2.5s infinite;
}

    .dragon-logo {
  width: 120px;
  animation: float 2s ease-in-out infinite;
}

.glow-red { animation: glowRed 1.5s ease-in-out infinite alternate, float 2s ease-in-out infinite; }
.glow-gold { animation: glowGold 1.5s ease-in-out infinite alternate, float 2s ease-in-out infinite; }
.glow-purple { animation: glowPurple 1.5s ease-in-out infinite alternate, float 2s ease-in-out infinite; }

@keyframes glowRed {
  from { filter: drop-shadow(0 0 5px #ff5555) drop-shadow(0 0 10px #ff0000); }
  to { filter: drop-shadow(0 0 15px #ff4444) drop-shadow(0 0 25px #ff1111); }
}
@keyframes glowGold {
  from { filter: drop-shadow(0 0 5px #ffd700) drop-shadow(0 0 10px #ffaa00); }
  to { filter: drop-shadow(0 0 15px #ffcc00) drop-shadow(0 0 25px #ffaa33); }
}
@keyframes glowPurple {
  from { filter: drop-shadow(0 0 5px #aa55ff) drop-shadow(0 0 10px #7700ff); }
  to { filter: drop-shadow(0 0 15px #bb66ff) drop-shadow(0 0 25px #9900ff); }
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-8px); }
}
  </style>
</head>
<body class="text-white">
<div class="overlay"></div>
<div id="root"></div>
  <div id="popup-root"></div>
<script type="text/babel">
const { useState, useEffect } = React;

// === CONSTANTS ===
const normalPunishments = [
  "Solve 100 GK/Current Affairs questions",
  "Revise 50 screenshot",
  "No Social Media for 6 hours + 1 mock section analysis",
  "Full Mock Test Analysis (check each wrong answer)",
  "25 Teaching Aptitude screenshots in 10 minutes (2 rounds)",
  "Give Science sectional mock test (2 tests)",
  "25 Science screenshots in 10 minutes (2 rounds)",
  "25 Current Affairs screenshots in 10 minutes (2 rounds)",
  "Revise screenshots for 20 minutes"
];

const deathModePunishments = [
  "Study 6 hours straight + make handwritten summary",
  "Solve 200 mixed questions (Maths, Reasoning, GK) + 50 push-ups",
  "Watch 4-5 concept videos continuously and make notes",
  "2 Full Mock Tests back-to-back + No Phone for 8 hours + Analysis",
  "Revise 8 topics (4 GK + 4 Maths/Reasoning) + Cold Shower",
  "Revise 200 screenshot"
  
];
const rankBadges = {
  E: "https://yourcdn.com/badge-stone.png",
  D: "https://yourcdn.com/badge-steel.png",
  C: "https://yourcdn.com/badge-bronze.png",
  B: "https://yourcdn.com/badge-silver.png",
  A: "https://yourcdn.com/badge-gold.png",
  S: "https://yourcdn.com/badge-crystal.png"
};
// Gamified RPG-style images for each level
// 11 ‡§Ø‡•Ç‡§®‡§ø‡§ï HD ‡§ó‡•á‡§Æ-‡§∏‡•ç‡§ü‡§æ‡§á‡§≤ ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ‡§á‡§Æ‡•á‡§ú‡•á‡§∏

const characterImages = [
  "images/jin1.png",  // Level 1 (Weak E-Rank)
  "images/jin2.png",  // Level 2
  "images/jin3.png",  // Level 3
  "images/jin4.png",  // Level 4
  "images/jin5.png",  // Level 5
  "images/jin6.png",  // Level 6
  "images/jin7.png",  // Level 7
  "images/jin8.png",  // Level 8
  "images/jin9.png",  // Level 9
  "images/jin10.png", // Level 10
  "images/jin11.png"  // Level 11 (Final Shadow Monarch)
];
const rewards = [
  "Watch 1 anime episode",
  "Eat your favorite snack",
  "Listen to 3-4 songs you love",
  "Take a relaxing walk for 20 minutes",
  "Watch Instagram for 20 minutes guilt-free"
];
const motivationalQuotes = [
  "‚öîÔ∏è Keep grinding, Shadow Monarch!",
  "üî• Your rival is training harder ‚Äì don‚Äôt fall behind!",
  "üíÄ Comfort is death, rise up!",
  "‚ö° Push limits, break chains!",
  "üèÜ Discipline > Motivation. Act now!",
  "ü©∏ Sacrifice today, glory tomorrow!",
  "üìö Every solved question is a sword strike against weakness.",
  "‚è≥ Time is running‚Ä¶ act before regret catches you.",
  "üëë You are the ruler of your fate ‚Äî don‚Äôt kneel before laziness.",
  "üí° Small progress daily > random bursts of energy.",
  "üåë Darkness is closing in ‚Äî light your fire with effort.",
  "üî• Train like your rival is watching every second.",
  "üíÄ If you stop, your rival wins instantly.",
  "‚ö° The harder you grind, the stronger you evolve.",
  "üèπ Aim sharp, strike precise ‚Äî distractions are your true enemy.",
  "üïõ 1 wasted hour = rival getting ahead forever.",
  "ü©∏ Pain is proof that you are still alive in the battle.",
  "‚öîÔ∏è A hunter never sleeps ‚Äî rise again, no excuses.",
  "üëÅÔ∏è The future you want is watching ‚Äî don‚Äôt betray it.",
  "üî• Discipline is the highest form of power.",
];

  const rewardMessages = [
  "‚òï Take a coffee/tea break ‚Äî you earned it!",
  "üéµ Listen to 1 song guilt-free.",
  "üç´ Eat a small snack you like.",
  "üö∂ Go for a 5 min walk.",
  "üì± 10 minutes social media allowed.",
  "üßò Stretch or meditate for 2 min.",
  "üìñ Read 2 pages of your fav book.",
  "üå≥ Go outside, breathe fresh air.",
  "üíß Drink water and stretch your back.",
  "üî• Quick dopamine refill: watch 1 short anime clip.",
  "üõ°Ô∏è Shadow Monarch grants you a rest ‚Äî but only 10 min!",
  "‚ö° Reward unlocked: write a random thought in your journal.",
];
// === DAILY QUEST EXERCISES (7 Days) ===
const weeklyQuestExercises = [
  // Day 1: Push (Chest + Shoulders + Triceps)
  [
    "Curl Bar Bench Press ‚Äì 4 √ó 8‚Äì10",
    "Incline Dumbbell Press ‚Äì 4 √ó 8‚Äì10",
    "Overhead Dumbbell Press ‚Äì 4 √ó 8‚Äì10",
    "Dumbbell Lateral Raise ‚Äì 3 √ó 12",
    "Overhead Dumbbell Tricep Extension ‚Äì 3 √ó 10"
  ],

  // Day 2: Pull (Back + Biceps)
  [
    "Curl Bar Bent Over Row ‚Äì 4 √ó 8‚Äì10",
    "One-Arm Dumbbell Row ‚Äì 4 √ó 10 each",
    "Reverse Fly (dumbbell) ‚Äì 3 √ó 12",
    "Curl Bar Bicep Curl ‚Äì 4 √ó 10",
    "Hammer Curl (dumbbell) ‚Äì 3 √ó 10"
  ],

  // Day 3: Active Recovery / Yoga
  [
    "Surya Namaskar ‚Äì 3 rounds",
    "Bhujangasana ‚Äì 2 √ó 30 sec",
    "Child‚Äôs Pose ‚Äì 2 √ó 30 sec",
    "Anulom Vilom ‚Äì 3 min",
    "Cat-Cow Stretch ‚Äì 2 min"
  ],

  // Day 4: Legs + Core
  [
    "Goblet Squat (dumbbell) ‚Äì 4 √ó 8‚Äì10",
    "Dumbbell Lunges ‚Äì 3 √ó 12 each",
    "Romanian Deadlift (dumbbell/curl bar) ‚Äì 4 √ó 8",
    "Calf Raise (dumbbell in hand) ‚Äì 3 √ó 15",
    "Russian Twist (dumbbell) ‚Äì 3 √ó 20"
  ],

  // Day 5: Push (variation)
  [
    "Incline Dumbbell Press ‚Äì 4 √ó 8‚Äì10",
    "Curl Bar Overhead Press ‚Äì 4 √ó 8‚Äì10",
    "Dumbbell Front Raise ‚Äì 3 √ó 12",
    "Close-Grip Curl Bar Press ‚Äì 3 √ó 8‚Äì10",
    "Dumbbell Shrugs ‚Äì 3 √ó 15"
  ],

  // Day 6: Pull (variation)
  [
    "Chin-Ups (agar possible, warna row repeat) ‚Äì 4 √ó max",
    "Curl Bar Row (underhand grip) ‚Äì 4 √ó 8‚Äì10",
    "One-Arm Dumbbell Row ‚Äì 4 √ó 10 each",
    "Incline Dumbbell Curl ‚Äì 3 √ó 10",
    "Face Pull / Reverse Fly ‚Äì 3 √ó 12"
  ],

  // Day 7: Rest / Yoga
  [
    "Surya Namaskar ‚Äì 3 rounds",
    "Vrikshasana ‚Äì 2 √ó 30 sec",
    "Forward Bend Stretch ‚Äì 2 √ó 20 sec",
    "Anulom Vilom ‚Äì 3 min",
    "Shavasana ‚Äì 5 min"
  ]
];
  
  const fogIncreaseOptions = [
  "Mindless scrolling",
  "Negative self-talk",
  "Skipping exercise",
  "Poor sleep",
  "Porn or instant gratification",
  "Avoiding tasks",
  "Unhealthy food",
  "Watching drama/TV",
  "Overthinking",
  "Unclear goals",
  "Too much comfort"
];

const fogReduceOptions = [
  "Cold shower",
  "Breathing exercise",
  "Meditation",
  "Shadow work",
  "Reading spiritual book",
  "Walking outdoors",
  "Doing deep work",
  "Helping others",
  "Waking early",
  "Writing journal",
  "Sunlight"
];

  
  // === BAD HABIT SELECTOR UI ===
const BadHabitUI = (
  <div id="habitPopup" style={{
    position: "fixed",
    inset: 0,
    background: "rgba(0,0,0,0.85)",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    zIndex: 99999
  }}>
    <div style={{
      width: "320px",
      background: "#0f0f1f",
      padding: "18px",
      borderRadius: "12px",
      border: "2px solid purple",
      color: "white"
    }}>
      <h3 style={{textAlign:"center", marginBottom:"10px"}}>‚ö†Ô∏è Select Bad Habit</h3>
      <div id="habitBtns" style={{display:"flex",flexDirection:"column",gap:"10px"}}></div>
    </div>
  </div>
);

// === SPIN WHEEL UI ===
const SpinWheelUI = (
  <div id="wheelPopup" style={{
    position:"fixed", inset:0,
    background:"rgba(0,0,0,0.85)",
    display:"flex", alignItems:"center", justifyContent:"center",
    zIndex:99999
  }}>
    <div 
  id="closeWheel" 
  style={{
    position: "absolute",
    top: "10px",
    right: "10px",
    width: "30px",
    height: "30px",
    borderRadius: "50%",
    background: "rgba(255,255,255,0.2)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    fontSize: "20px",
    color: "white",
    cursor: "pointer",
    zIndex: 9999,
    backdropFilter: "blur(4px)"
  }}
>
  ‚úï
</div>
    <div style={{position:"relative", textAlign:"center"}}>

      <div style={{
        width:0, height:0,
        borderLeft:"20px solid transparent",
        borderRight:"20px solid transparent",
        borderBottom:"35px solid yellow",
        position:"absolute", top:"-45px", left:"50%",
        transform:"translateX(-50%)",
        filter:"drop-shadow(0px 0px 10px yellow)"
      }}></div>

      <div id="spinWheel" style={{
        width:"300px", height:"300px",
        borderRadius:"50%", overflow:"hidden",
        border:"8px solid purple",
        transition:"4s cubic-bezier(.17,.67,.25,1.25)",
        boxShadow:"0 0 20px purple"
      }}></div>

      <button id="spinBtn" style={{
        marginTop:"20px", padding:"10px 20px",
        background:"purple", color:"white",
        border:"none", borderRadius:"10px",
        cursor:"pointer"
      }}>SPIN</button>

    </div>
  </div>
);

  // === SPIN WHEEL VARIABLES ===
let wheelOptions = [
  "XP -30",
  "Fog +10%",
  "Study Timer 25 min",
  "10 Push-ups",
  "Fog Spike +15%",
  "Double Punishment",
  "Watch YouTube 30 min",
  "MiniBoss Fight",
  "Lock Social Media"
];

let spinning = false;
let wheelAngle = 0;
  
  const badHabits = [
  "Wasted Time",
  "Mindless Scrolling",
  "Checked Social Media",
  "Procrastinated",
  "Long Break",
  "Avoided Study"
];

function renderBadHabitButtons() {
  const box = document.getElementById("habitBtns");
  if (!box) {
    console.log("habitBtns NOT FOUND");
    return;
  }

  box.innerHTML = "";

  badHabits.forEach(habit => {
    const btn = document.createElement("button");
    btn.innerText = habit;
    btn.style.padding = "10px";
    btn.style.background = "#6d28d9";
    btn.style.color = "white";
    btn.style.border = "none";
    btn.style.borderRadius = "8px";
    btn.onclick = () => {
      closeHabitPopup();  
      openSpinWheel();    // ‚Üê THE IMPORTANT PART
    };
    box.appendChild(btn);
  });
  }

function openBadHabitSelector() {
  const root = document.getElementById("popup-root");
  const renderer = ReactDOM.createRoot(root);
  
  renderer.render(BadHabitUI);

  // TRIPLE CHECK LOADER (very important)
  let tries = 0;
  const tryRender = setInterval(() => {
    const box = document.getElementById("habitBtns");
    if (box) {
      clearInterval(tryRender);
      renderBadHabitButtons();
    }
    tries++;
    if (tries > 20) clearInterval(tryRender); // max 400ms
  }, 20);
  }
  
function openSpinWheel() {
  const popup = document.getElementById("popup-root");
  const renderer = ReactDOM.createRoot(popup);
  renderer.render(SpinWheelUI);

  let tries = 0;

  const wait = setInterval(() => {
    const wheel = document.getElementById("spinWheel");
    const btn = document.getElementById("spinBtn");

    if (wheel && btn) {
      clearInterval(wait);

      renderWheelSlices();

      btn.onclick = () => {
        spinWheel(result => {
          applyWheelResult(result);
        });
      };
    }

    tries++;
    if (tries > 50) clearInterval(wait);
  }, 25);

  const closeBtn = document.getElementById("closeWheel");
if (closeBtn) {
  closeBtn.onclick = () => {
    document.getElementById("popup-root").innerHTML = "";
  };
  }
  }
  
function closeHabitPopup() {
  ReactDOM.createRoot(document.getElementById("popup-root")).render(<div></div>);
  }
  
function spinWheel(callback) {
  if (spinning) return;
  spinning = true;

  const wheel = document.getElementById("spinWheel");

  const fullRot = 360 * 6;
  const finalExtra = Math.floor(Math.random() * 360);
  const finalSpin = fullRot + finalExtra;

  wheelAngle += finalSpin;

  wheel.style.transform = `rotate(${wheelAngle}deg)`;

  setTimeout(() => {
    spinning = false;

    const normalized = ((wheelAngle % 360) + 360) % 360;
    const sliceSize = 360 / wheelOptions.length;

    const index = Math.floor(normalized / sliceSize);

    const result = wheelOptions[
      (wheelOptions.length - index) % wheelOptions.length
    ];

    callback(result);
  }, 4200);
  }

  function renderWheelSlices() {
  const wheel = document.getElementById("spinWheel");
  wheel.innerHTML = "";

  const count = wheelOptions.length;
  const deg = 360 / count;

  wheelOptions.forEach((label, i) => {
    const slice = document.createElement("div");
    slice.style.position = "absolute";
    slice.style.width = "50%";
    slice.style.height = "50%";
    slice.style.left = "50%";
    slice.style.top = "50%";
    slice.style.transformOrigin = "0 0";
    slice.style.transform = `rotate(${i * deg}deg)`;
    slice.style.clipPath = "polygon(0 0, 100% 0, 0 100%)";
    slice.style.background = (i % 2 === 0) ? "#8b5cf6" : "#d946ef";

    const txt = document.createElement("div");
    txt.innerText = label;
    txt.style.position = "absolute";
    txt.style.left = "10px";
    txt.style.top = "30px";
    txt.style.transform = `rotate(${deg / 2}deg)`;
    txt.style.color = "white";
    txt.style.fontWeight = "bold";
    txt.style.fontSize = "12px";

    slice.appendChild(txt);
    wheel.appendChild(slice);
  });
  }

  function applyWheelResult(result) {
  if (result.includes("XP -")) {
    const val = parseInt(result.replace("XP -", "").trim());
    const prev = parseInt(localStorage.getItem("xp") || "0");
    localStorage.setItem("xp", prev - val);
    alert("XP -" + val);
  }

  if (result.includes("XP +")) {
    const val = parseInt(result.replace("XP +", "").trim());
    const prev = parseInt(localStorage.getItem("xp") || "0");
    localStorage.setItem("xp", prev + val);
    alert("XP +" + val);
  }

  if (result.includes("Fog +")) {
    const val = parseInt(result.replace("Fog +", "").trim());
    const prev = parseInt(localStorage.getItem("fog") || "0");
    localStorage.setItem("fog", prev + val);
    alert("Fog +" + val);
  }

  if (result.includes("Fog -")) {
    const val = parseInt(result.replace("Fog -", "").trim());
    const prev = parseInt(localStorage.getItem("fog") || "0");
    localStorage.setItem("fog", prev - val);
    alert("Fog -" + val);
  }

  if (result === "LockSocial") {
    localStorage.setItem("social_block", "1");
    alert("Social Blocked Today!");
  }

  if (result === "Pushups") {
    alert("Do 10 Pushups RIGHT NOW!");
  }

  if (result === "Study Timer 25 min") {
    localStorage.setItem("forcedStudy", "25");
    alert("Study 25 Minutes NOW!");
  }
  }
// === XP SYSTEM ===
const rankTitles = ['E-Rank Hunter','D-Rank','C-Rank','B-Rank','A-Rank','S-Rank'];


function getXPForLevel(level){ return level*level*100; }
function getRank(level){
  if(level<5)return rankTitles[0];
  if(level<10)return rankTitles[1];
  if(level<15)return rankTitles[2];
  if(level<20)return rankTitles[3];
  if(level<25)return rankTitles[4];
  return rankTitles[5];
}

// Rival XP constants


  // === MAIN APP ===
function App(){
  // pehle se jo states hain unke sath yeh add karo
  const [debt, setDebt] = React.useState(parseInt(localStorage.getItem('debt')) || 0);
  const [showDebtModal, setShowDebtModal] = React.useState(false);
  const [currentRepaymentTask, setCurrentRepaymentTask] = React.useState("");

  const repaymentTasks = [
    "Solve 20 maths questions",
    "Do 20 push-ups",
    "Read 5 pages of a GK",
    "Watch youtube gk shorts 15 min",
    "Watch YouTube maths shorts 15 min",
    "revise screenshot 15 min",
    "Do 10 squats",
    "Drink 2 glasses of water and walk 5 mins",
    "Revise 1 topic you are weak at",
    "Clean your room for 10 minutes"
  ];
  const [xp,setXP]=useState(parseInt(localStorage.getItem('xp'))||0);
  const [level,setLevel]=useState(parseInt(localStorage.getItem('level'))||1);
  const [tasks,setTasks]=useState(JSON.parse(localStorage.getItem('tasks'))||[]);
  const [taskLog, setTaskLog] = useState(JSON.parse(localStorage.getItem('taskLog')) || []);
  const [habits,setHabits]=useState(JSON.parse(localStorage.getItem('habits'))||[]);
  const [punishments,setPunishments]=useState(JSON.parse(localStorage.getItem('punishments'))||[]);
  const [showAddModal,setShowAddModal]=useState(false);
  const [newTask,setNewTask]=useState({type:'daily',title:'',start:'',end:'',days:''});
  const [bossCountdown,setBossCountdown]=useState(parseInt(localStorage.getItem('bossCountdown'))||0);
 const [rivalXP,setRivalXP]=useState(parseFloat(localStorage.getItem('rivalXP'))||0);
  const [rivalLevel,setRivalLevel]=useState(parseInt(localStorage.getItem('rivalLevel'))||1);
//  const [rival, setRival] = useState(() => ({
//  xp: parseFloat(localStorage.getItem("rivalXP")) || 0,
//  level: parseFloat(localStorage.getItem("rivalLevel")) || 1
  
// }));
  // Wake up tracking
  // === Emergency Day State ===
const [showEmergencyModal, setShowEmergencyModal] = useState(false);
const [emergencyUsed, setEmergencyUsed] = useState(
  JSON.parse(localStorage.getItem("emergencyUsed") || "false")
);
  // === Focus Mode & Break states ===
const [focusActive, setFocusActive] = useState(false);
const [focusStartTime, setFocusStartTime] = useState(null);
const [focusDuration, setFocusDuration] = useState(0); // minutes
const [focusRemaining, setFocusRemaining] = useState(0); // seconds

const [onBreak, setOnBreak] = useState(false);
const [breakRemaining, setBreakRemaining] = useState(0); // seconds

const [focusStats, setFocusStats] = useState(
  JSON.parse(localStorage.getItem("focusStats") || "[]")
);

  // ---------- Proof modal / missed-task accountability ----------
const [showProofModal, setShowProofModal] = useState(false);
const [proofTask, setProofTask] = useState(null);
const [proofText, setProofText] = useState("");
const [proofImage, setProofImage] = useState(null);

// track pending proof timeouts so we can clear them
const proofTimeoutsRef = React.useRef({});

// grace period (ms) to allow proof after task end ‚Äî change if you want
const PROOF_GRACE_MS = 15 * 60 * 1000; // 15 minutes

  
  const anchorTimes = [
  { id: 1, time: "06:00", label: "Dawn" },
  { id: 2, time: "12:00", label: "Noon" },
  { id: 3, time: "18:00", label: "Dusk" },
  { id: 4, time: "22:00", label: "Nightfall" }
];

const [anchorsDone, setAnchorsDone] = useState(
  JSON.parse(localStorage.getItem("anchorsDone")) || {}
);
  // ----- Shadow Contracts state -----
const [contracts, setContracts] = useState(
  JSON.parse(localStorage.getItem("shadowContracts")) || []
);
const [showNewContract, setShowNewContract] = useState(false);
const [contractGoalInput, setContractGoalInput] = useState("");
const [contractDaysInput, setContractDaysInput] = useState("");
const [uiLockedByContract, setUiLockedByContract] = useState(false); // locks UI when no active contract
const [wakeUpOnTime, setWakeUpOnTime] = useState(
  JSON.parse(localStorage.getItem("wakeUpOnTime")) || false
);

// Mock percentile tracking
const [mockPercentile, setMockPercentile] = useState(
  parseInt(localStorage.getItem("mockPercentile")) || 0
);
  
  const now = Date.now();
//const lastUpdate = parseInt(localStorage.getItem('lastRivalUpdate')) || now;
  const [behindDays,setBehindDays]=useState(parseInt(localStorage.getItem('behindDays'))||0);
  const [showLevelUp,setShowLevelUp]=useState(false);
  const [lockdown,setLockdown]=useState(false);
  const [timer,setTimer]=useState(getRemainingBossTime());
  const [showDailyQuest,setShowDailyQuest]=useState(false);
  const [dailyQuestList,setDailyQuestList]=useState([]);
  // Mock Test Tracker states
const [mockHistory, setMockHistory] = useState(
  JSON.parse(localStorage.getItem("mockHistory")) || []
);
const [bestPercentile, setBestPercentile] = useState(
  parseInt(localStorage.getItem("bestPercentile")) || 80
);
const [failStreak, setFailStreak] = useState(
  parseInt(localStorage.getItem("failStreak")) || 0
);
const [graceDeadline, setGraceDeadline] = useState(
  parseInt(localStorage.getItem("graceDeadline")) || 0
);
const [tempPercentile, setTempPercentile] = useState("");
  
// State
const [dopamineActive, setDopamineActive] = useState(
  JSON.parse(localStorage.getItem("dopamineActive")) || false
);
const [dopamineLevel, setDopamineLevel] = useState(
  parseFloat(localStorage.getItem("dopamineLevel")) || 100
);
const [lastUpdate, setLastUpdate] = useState(
  parseInt(localStorage.getItem("dopamineLastUpdate")) || Date.now()
);
const [timeRemaining, setTimeRemaining] = useState("02:00:00"); // üü¢ Yahi missing tha
  
  const [smallBossCount, setSmallBossCount] = useState(parseInt(localStorage.getItem('smallBossCount')) || 0);
  const [showUrgeModal, setShowUrgeModal] = useState(false);
  const [urgeTask, setUrgeTask] = useState('');
  const urgeTasks = [
  "Do 10 push-ups now!",
  "sleep on left side.",
  "Take 10 deep breaths.",
  "Drink a glass of water.",
  "Do 10 squat."
   ];
  
  const [fogReason, setFogReason] = useState('');
const [relapseHua, setRelapseHua] = useState(false);
  const [fogLevel, setFogLevel] = useState(() => {
  const saved = localStorage.getItem("fogLevel");
  return saved !== null ? parseInt(saved) : 20;
}); // Starts at 20%
  const [selectedHistoryDay, setSelectedHistoryDay] = useState(null);
  // Architect states
const [showArchitect, setShowArchitect] = useState(false);
const [architectMessage, setArchitectMessage] = useState("");
const [architectMood, setArchitectMood] = useState("neutral"); // "positive" / "negative"
const [architectThreshold, setArchitectThreshold] = useState(parseInt(localStorage.getItem('architectThreshold')) || 85);
const [architectPositiveStreak, setArchitectPositiveStreak] = useState(parseInt(localStorage.getItem('architectPositiveStreak')) || 0);
const [architectNegativeStreak, setArchitectNegativeStreak] = useState(parseInt(localStorage.getItem('architectNegativeStreak')) || 0);
  function triggerUrgeRedirect() {
  setUrgeTask(urgeTasks[Math.floor(Math.random() * urgeTasks.length)]);
  setShowUrgeModal(true);

  // Auto complete after 10 sec
  setTimeout(() => {
    if (showUrgeModal) {
      handleUrgeComplete();
    }
  }, 10000);
  }
// ---- STATE (add with your other states) ----
  const [showMotivation, setShowMotivation] = useState(false);
const [motivationText, setMotivationText] = useState("");
  
  // ---- States ----
const [showDisrespectModal, setShowDisrespectModal] = React.useState(false);
const [challengeType, setChallengeType] = React.useState("");
const [challengeTarget, setChallengeTarget] = React.useState(0);
const [challengeDuration, setChallengeDuration] = React.useState(0);

const [challenge, setChallenge] = React.useState(() => {
  const saved = localStorage.getItem("disrespectChallenge");
  return saved ? JSON.parse(saved) : null;
});

const [status, setStatus] = React.useState(""); // "", "completed", "failed"


// === REWARD SYSTEM ===

// Reward states
const [showReward, setShowReward] = useState(false);
const [rewardText, setRewardText] = useState("");
const [rewardTime, setRewardTime] = useState(0);
const [rewardActive, setRewardActive] = useState(false);
const [tasksCompletedCount, setTasksCompletedCount] = useState(0);
  
// === Anchor modal (custom interactive) ===
const [showAnchorModal, setShowAnchorModal] = useState(false);
const [currentAnchor, setCurrentAnchor] = useState(null);
const [anchorQueueLock, setAnchorQueueLock] = useState(false); // prevent double popups

  const [dailyQuestion, setDailyQuestion] = React.useState(localStorage.getItem("dailyQuestion") || "");
const [dailyAnswer, setDailyAnswer] = React.useState(localStorage.getItem("dailyAnswer") || "");
const [questionDone, setQuestionDone] = React.useState(localStorage.getItem("questionDone") === "true");
const [lastQuestionDay, setLastQuestionDay] = React.useState(localStorage.getItem("lastQuestionDay") || "");
  // üü• CONTRACT SYSTEM ‚Äî Independent Modal
const [showContractModal, setShowContractModal] = useState(false);
const [contractModalMessage, setContractModalMessage] = useState("");

  // ==========================================================
// üîÆ JOURNAL OF RESOLVE - FUNCTIONS
// ==========================================================

// üß± STATES (define these in App() state section)
const [showJournalModal, setShowJournalModal] = React.useState(false);
const [viewEntryModal, setViewEntryModal] = React.useState(null);
const [editEntryId, setEditEntryId] = React.useState(null);
const [crystals, setCrystals] = React.useState([]);
const [situation, setSituation] = React.useState("");
const [lesson, setLesson] = React.useState("");
const [resolveText, setResolveText] = React.useState("");
const [journalToast, setJournalToast] = React.useState("");


  const [showSettings, setShowSettings] = useState(false);
const [difficulty, setDifficulty] = useState(localStorage.getItem("difficulty") || "medium");
const [settings, setSettings] = useState(() => ({
  rivalXP: parseInt(localStorage.getItem("rivalXPdaily")) || 70,
  architectThreshold: parseInt(localStorage.getItem("architectThreshold")) || 80,
  fogRate: parseFloat(localStorage.getItem("fogRate")) || 1.0,
  debtPenalty: parseInt(localStorage.getItem("debtPenalty")) || 3,
  focusReward: parseInt(localStorage.getItem("focusReward")) || 5,
}));

const presets = {
  easy:    { rivalXP: 40, threshold: 60, fogRate: 0.8, debtPenalty: 2, focusReward: 6 },
  medium:  { rivalXP: 70, threshold: 70, fogRate: 1.0, debtPenalty: 3, focusReward: 5 },
  hard:    { rivalXP: 90, threshold: 80, fogRate: 1.2, debtPenalty: 5, focusReward: 4 },
  monarch: { rivalXP: 100,threshold: 90, fogRate: 1.4, debtPenalty: 6, focusReward: 3 },
};

// === Architect Crystals ===
const [architectCrystals, setArchitectCrystals] = useState(
  JSON.parse(localStorage.getItem("architectCrystals") || "[]")
);

// üïí Duration Modal states
const [showDurationModal, setShowDurationModal] = useState(false);
const [durationType, setDurationType] = useState("");
const [durationTitle, setDurationTitle] = useState("");
const [durationMinutes, setDurationMinutes] = useState("");
  
// productive UI states
const [productiveMinutes, setProductiveMinutes] = useState(Number(localStorage.getItem("productiveMinutes") || 0));
const [wastageMinutes, setWastageMinutes] = useState(Number(localStorage.getItem("wastageMinutes") || 0));

// app-usage states
const [activeApp, setActiveApp] = useState(null);
const [appStartTime, setAppStartTime] = useState(null);
const [appElapsed, setAppElapsed] = useState(0);
const [showAppUsageModal, setShowAppUsageModal] = useState(false);


  
// duration modal (punishment/dungeon) states you already added ‚Äî keep them
// const [showDurationModal,...] etc.

  // === helper: unified add productive time ===
function addProductiveTime(minutes, source = "General") {
  const prev = Number(localStorage.getItem("productiveMinutes") || 0);
  const newTotal = prev + Number(minutes);
  localStorage.setItem("productiveMinutes", newTotal);
  setProductiveMinutes(newTotal);

  // optional history log
  const history = JSON.parse(localStorage.getItem("manualActivities") || "[]");
  history.push({
    date: new Date().toISOString().split("T")[0],
    type: source,
    title: `${source}`,
    minutes: Number(minutes),
  });
  localStorage.setItem("manualActivities", JSON.stringify(history));

  console.log(`‚úÖ ${source}: +${minutes} min`);
  }

// Start tracking an app session (call from shortcut buttons)
function startAppUsage(appName, appURL) {
  setActiveApp(appName);
  setAppStartTime(Date.now());
  // try to open web version in new tab - optional
  try { window.open(appURL, "_blank"); } catch (e) { /* ignore */ }
  console.log(`‚ñ∂ Started ${appName}`);
}

// Stop tracking (user presses Stop timer in UI)
function stopAppUsage() {
  if (!appStartTime || !activeApp) return;
  const elapsedMs = Date.now() - appStartTime;
  const minutes = Math.max(1, Math.round(elapsedMs / 60000)); // at least 1 min
  setAppElapsed(minutes);
  setShowAppUsageModal(true);
}

// Handle productiv/waste selection from modal
function handleAppUsageResult(choice) {
  const minutes = Number(appElapsed || 0);
  if (minutes <= 0) {
    setShowAppUsageModal(false);
    setActiveApp(null);
    setAppStartTime(null);
    setAppElapsed(0);
    return;
  }

  if (choice === "productive") {
    addProductiveTime(minutes, `App: ${activeApp}`);
  } else {
    const prev = Number(localStorage.getItem("wastageMinutes") || 0);
    const newTotal = prev + minutes;
    localStorage.setItem("wastageMinutes", newTotal);
    setWastageMinutes(newTotal);

    // log
    const history = JSON.parse(localStorage.getItem("manualActivities") || "[]");
    history.push({
      date: new Date().toISOString().split("T")[0],
      type: "AppUsage",
      title: `${activeApp} (waste)`,
      minutes,
    });
    localStorage.setItem("manualActivities", JSON.stringify(history));
  }

  // reset active session
  setShowAppUsageModal(false);
  setActiveApp(null);
  setAppElapsed(0);
  setAppStartTime(null);
  }
  
// üîπ Open modal
function openDurationModal(type, title) {
  setDurationType(type);
  setDurationTitle(title);
  setDurationMinutes("");
  setShowDurationModal(true);
}

// üîπ Save duration
  function handleDurationSave() {
  try {
    console.log("‚è≥ handleDurationSave triggered", durationMinutes);
    const mins = Number(durationMinutes);
    if (!mins || mins <= 0) {
      alert("Enter valid minutes!");
      return;
    }

    // üßÆ Add to productive minutes
    const prev = Number(localStorage.getItem("productiveMinutes") || 0);
    localStorage.setItem("productiveMinutes", prev + mins);
setProductiveMinutes(prev => prev + mins);
    
    // üßæ Save to manual history
    const history = JSON.parse(localStorage.getItem("manualActivities") || "[]");
    history.push({
      date: new Date().toISOString().split("T")[0],
      type: durationType,
      title: durationTitle,
      minutes: mins,
    });
    localStorage.setItem("manualActivities", JSON.stringify(history));

    console.log(
      `‚úÖ ${durationType} completed: ${durationTitle} (+${mins} min productive time)`
    );

    // üßπ Clean pending punishment if it exists
    const idx = localStorage.getItem("pendingPunishmentIndex");
    if (idx !== null) {
      const index = Number(idx);
      const punishments = JSON.parse(localStorage.getItem("punishments")) || [];

      if (punishments[index]) {
        punishments.splice(index, 1); // remove completed punishment
        localStorage.setItem("punishments", JSON.stringify(punishments));
        setPunishments(punishments);
        console.log("üßπ Removed punishment index:", index);
      }

      localStorage.removeItem("pendingPunishmentIndex");
    }

    // ‚úÖ Close modal
    setShowDurationModal(false);

    // üü¢ Optional: small feedback popup
    alert("‚úÖ Saved successfully and punishment completed!");

  } catch (err) {
    console.error("Error saving duration:", err);
  }
  }

function saveArchitectCrystals(arr) {
  setArchitectCrystals(arr);
  localStorage.setItem("architectCrystals", JSON.stringify(arr));
}

function addArchitectCrystal(reason, bonus = 5) {
  const newCrystal = {
    id: Date.now(),
    date: new Date().toLocaleDateString(),
    reason,
    xpValue: bonus,
  };
  const updated = [...architectCrystals, newCrystal];
  saveArchitectCrystals(updated);
  addJournalEntry?.(`üíé Architect forged a crystal: ${reason}`);
}

function useArchitectCrystal(id) {
  const crystal = architectCrystals.find((c) => c.id === id);
  if (!crystal) return alert("No such crystal found.");
  const updated = architectCrystals.filter((c) => c.id !== id);
  saveArchitectCrystals(updated);

  setXP((prev) => {
    const next = prev + crystal.xpValue;
    localStorage.setItem("xp", String(next));
    return next;
  });
  setFogLevel((prev) => Math.max(0, prev - 5));
  setDebt?.((prev) => Math.max(0, prev - 2));
  addJournalEntry?.(`‚ú® Absorbed an Architect Crystal ‚Üí +${crystal.xpValue} XP, ‚Äì5 Fog, ‚Äì2 Debt`);
  alert(`‚ú® Absorbed Architect Crystal ‚Üí +${crystal.xpValue} XP, ‚Äì5 Fog, ‚Äì2 Debt`);
  }
  
function applyPreset(level) {
  const p = presets[level];
  setSettings({
    rivalXP: p.rivalXP,
    architectThreshold: p.threshold,
    fogRate: p.fogRate,
    debtPenalty: p.debtPenalty,
    focusReward: p.focusReward,
  });
  setDifficulty(level);
  Object.entries(p).forEach(([key, val]) =>
    localStorage.setItem(key === "threshold" ? "architectThreshold" : key, val)
  );
  localStorage.setItem("difficulty", level);
  }
  
// üß© Load crystals from localStorage
function loadCrystals() {
  try {
    const saved = JSON.parse(localStorage.getItem("crystals") || "[]");
    setCrystals(saved);
  } catch (e) {
    console.error("Error loading crystals", e);
  }
}

// üíæ Save crystals to localStorage
function saveCrystalsToLocal(data) {
  localStorage.setItem("crystals", JSON.stringify(data));
}

// ‚ûï Add or Update Journal Entry
function saveJournalEntry() {
  if (!lesson.trim() || !resolveText.trim()) return;

  if (editEntryId) {
    // update existing entry
    const updated = crystals.map(c =>
      c.id === editEntryId
        ? { ...c, situation, lesson, resolve: resolveText, date: new Date().toLocaleDateString() }
        : c
    );
    setCrystals(updated);
    saveCrystalsToLocal(updated);
    setEditEntryId(null);
    showJournalToast("ü™∂ Entry updated");
  } else {
    // create new entry
    const newCrystal = {
      id: Date.now(),
      date: new Date().toLocaleDateString(),
      situation,
      lesson,
      resolve: resolveText,
      xpValue: 5,
    };
    const updated = [...crystals, newCrystal];
    setCrystals(updated);
    saveCrystalsToLocal(updated);
    setXP(xp + 3);
    setFogLevel(Math.max(0, fogLevel - 3));
    showJournalToast("üíé Crystal forged! Fog ‚Äì3%, +3 XP");
  }

  clearJournalInputs();
  setShowJournalModal(false);
}

// üßπ Clear all input fields
function clearJournalInputs() {
  setSituation("");
  setLesson("");
  setResolveText("");
}

// üß† Edit an existing entry
function editJournalEntry(entry) {
  setSituation(entry.situation);
  setLesson(entry.lesson);
  setResolveText(entry.resolve);
  setEditEntryId(entry.id);
  setShowJournalModal(true);
}

// üëÅ View entry (read-only)
function viewJournalEntry(entry) {
  setViewEntryModal(entry);
}

// üíé Absorb Crystal (gain XP & remove)
function absorbCrystal(id) {
  const crystal = crystals.find(c => c.id === id);
  if (!crystal) return;
  const updated = crystals.filter(c => c.id !== id);
  setCrystals(updated);
  saveCrystalsToLocal(updated);
  setXP(xp + crystal.xpValue);
  setFogLevel(Math.max(0, fogLevel - 2));
  showJournalToast(`‚ú® Crystal absorbed +${crystal.xpValue} XP`);
  navigator.vibrate?.([100, 50, 100]);
}

// üí¨ Toast helper
function showJournalToast(msg) {
  setJournalToast(msg);
  setTimeout(() => setJournalToast(""), 3000);
  }
  
function openAnchorModal(anchor) {
  // prevent opening multiple modals at once
  if (anchorQueueLock) return;
  setAnchorQueueLock(true);
  setCurrentAnchor(anchor);
  setShowAnchorModal(true);
}

function handleAnchorAnswer(answer) {
  if (!currentAnchor) return;
  const a = currentAnchor;
  const newStatus = { ...anchorsDone, [a.id]: answer ? "yes" : "no" };
  setAnchorsDone(newStatus);
  localStorage.setItem("anchorsDone", JSON.stringify(newStatus));
  setShowAnchorModal(false);
  setCurrentAnchor(null);
  setAnchorQueueLock(false);

  if (answer) {
    setXP(prev => prev + 2);  // reward
  } else {
    setXP(prev => Math.max(0, prev - 5)); // penalty
  }
  }

// ‚úÖ Handle Task Completion
function handleTaskCompletion() {
  setTasksCompletedCount(prevCount => {
    const newCount = prevCount + 1;

    // Har 3 task complete hone par reward trigger
    if (newCount % 3 === 0) {
      const randomReward = rewardMessages[Math.floor(Math.random() * rewardMessages.length)];
      setRewardText(randomReward);
      setShowReward(true);
      setRewardTime(0);
      setRewardActive(false);
    }

    return newCount;
  });
}

// ‚úÖ Reward timer countdown
useEffect(() => {
  let interval;
  if (rewardActive && rewardTime > 0) {
    interval = setInterval(() => {
      setRewardTime(prev => {
        if (prev <= 1) {
          setShowReward(false);
          setRewardActive(false);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  }
  return () => clearInterval(interval);
}, [rewardActive, rewardTime]);




// Save to localStorage
React.useEffect(() => {
  if (challenge) {
    localStorage.setItem("disrespectChallenge", JSON.stringify(challenge));
  } else {
    localStorage.removeItem("disrespectChallenge");
  }
}, [challenge]);

  // Save contracts to localStorage
function saveContracts(arr) {
  setContracts(arr);
  localStorage.setItem("shadowContracts", JSON.stringify(arr));
}

// Create a new contract (manual)
function createContractFromInputs() {
  if (!contractGoalInput.trim() || !contractDaysInput) {
    alert("‚ö†Ô∏è Enter goal and days");
    return;
  }
  const days = Number(contractDaysInput);
  const start = Date.now();
  const end = start + days * 24 * 60 * 60 * 1000;
  const progress = Array(days).fill(false);
  const newContract = {
    id: Date.now(),
    goal: contractGoalInput.trim(),
    start,
    end,
    days,
    progress,
    done: false,
    failed: false
  };
  const updated = [...contracts, newContract];
  saveContracts(updated);
  setContractGoalInput("");
  setContractDaysInput("");
  setShowNewContract(false);
  alert(`üïØÔ∏è Contract created: "${newContract.goal}" (${days} days)`);
  ensureContractsActive(updated);
}

// Mark today's progress for a contract
function markContractProgress(id) {
  const now = Date.now();
  const updated = contracts.map(c => {
    if (c.id !== id || c.done || c.failed) return c;
    const dayIndex = Math.floor((now - c.start) / (24*60*60*1000));
    if (dayIndex >= 0 && dayIndex < c.days) {
      const newProg = [...c.progress];
      newProg[dayIndex] = true;
      return { ...c, progress: newProg };
    }
    return c;
  });
  saveContracts(updated);
}

// Force contract end (call on success)
function completeContract(id) {
  const updated = contracts.map(c => c.id === id ? { ...c, done: true } : c);
  saveContracts(updated);
  // rewards
  setXP(prev => prev + 15);
  setFogLevel(prev => Math.max(0, prev - 20));
  alert("‚úÖ Contract completed! +15 XP, -20% Fog");
  handleContractsPostEnd(updated);
}

// Force fail on contract id
function failContract(id) {
  const target = contracts.find(c => c.id === id);
  const updated = contracts.map(c => c.id === id ? { ...c, failed: true } : c);
  saveContracts(updated);
  addPunishment({
    type: "contractFail",
    text: `üíÄ Contract failed: "${target?.goal || 'unknown'}"`,
    deathMode: true
  });
  increaseDebt(10);
  setXP(prev => Math.max(0, prev - 10));
  alert(`üíÄ Contract failed: "${target?.goal}" ‚Äî punishment added.`);
  handleContractsPostEnd(updated);
}

// Check if there is at least one active (not done/failed) contract
function hasActiveContract(arr = contracts) {
  return arr.some(c => !c.done && !c.failed);
  }

  // Whenever contracts change, ensure at least one active contract exists
function ensureContractsActive(arr = contracts) {
  if (!hasActiveContract(arr)) {
    // lock UI and force new-contract modal
    setUiLockedByContract(true);
    setShowNewContract(true);
    // optionally set app-level lockdown too
    setLockdown(true);
    alert("‚öîÔ∏è No active contract! Forge a new Contract now ‚Äî app locked until you do.");
  } else {
    setUiLockedByContract(false);
    // if no punishments and not otherwise locked, unlock UI
    if (punishments.length === 0) setLockdown(false);
  }
}

// run once on load to enforce rule
useEffect(() => {
  ensureContractsActive();
}, []);

  function handleContractsPostEnd(updatedContracts) {
  // Save already called by caller; just ensure chain continues
  if (!hasActiveContract(updatedContracts)) {
    // Force prompt for new contract
    setTimeout(() => {
      setShowNewContract(true);
      setUiLockedByContract(true);
      setLockdown(true);
      alert("üïØÔ∏è Contract cycle ended. Forge the next one immediately.");
    }, 800);
  } else {
    // unlock if there is at least one active contract
    setUiLockedByContract(false);
    if (punishments.length === 0) setLockdown(false);
  }
  }

  function autoMarkContractsForGoal(taskTitle) {
  // Look for contracts whose goal text contains a keyword from taskTitle (simple fuzzy match)
  const updated = contracts.map(c => {
    if (c.done || c.failed) return c;
    const goalLower = c.goal.toLowerCase();
    const titleLower = (taskTitle || "").toLowerCase();
    // If task title seems relevant to contract goal, mark today's progress
    if (goalLower.includes(titleLower) || titleLower.includes(goalLower) || goalLower.split(' ')[0] === titleLower.split(' ')[0]) {
      const now = Date.now();
      const dayIndex = Math.floor((now - c.start) / (24*60*60*1000));
      if (dayIndex >=0 && dayIndex < c.days) {
        const newProg = [...c.progress];
        newProg[dayIndex] = true;
        return { ...c, progress: newProg };
      }
    }
    return c;
  });
  saveContracts(updated);
  }
  
  
  function showAnchorPopup(anchor) {
  // backwards compatible wrapper
  openAnchorModal(anchor);
  }
  // === Automatic cleanup of old proof images ===
function autoCleanOldProofs(days = 5) {
  const now = Date.now();
  const limit = days * 24 * 60 * 60 * 1000; // convert days to ms
  const tasks = JSON.parse(localStorage.getItem("tasks") || "[]");
  let cleaned = false;

  const updated = tasks.map(t => {
    if (t.proofImage && t.missedAt && now - t.missedAt > limit) {
      cleaned = true;
      return { ...t, proofImage: null };
    }
    return t;
  });

  if (cleaned) {
    localStorage.setItem("tasks", JSON.stringify(updated));
    console.log("üßπ Old proof images cleaned (older than " + days + " days)");
  }
  }


  function startFocusSession(minutes) {
  if (focusActive) return alert("Focus Mode already active!");
  if (onBreak) return alert("Currently on break ‚Äî finish break first.");

  setFocusActive(true);
  setFocusStartTime(Date.now());
  setFocusDuration(minutes);
  setFocusRemaining(minutes * 60); // convert to seconds

  // persist so session can resume after reload
  localStorage.setItem(
    "focusSession",
    JSON.stringify({ active: true, start: Date.now(), duration: minutes })
  );

  // optional: small motivational message
  setTimeout(() => alert(`üïØÔ∏è Focus started for ${minutes} min ‚Äî stay in the zone.`), 200);
  }
  function endFocusSession(success) {
  // stop and cleanup
  setFocusActive(false);
  localStorage.removeItem("focusSession");

  if (success) {
    // record stat
    const session = { date: new Date().toLocaleDateString(), minutes: focusDuration };
    const updated = [...focusStats, session];
    setFocusStats(updated);
    localStorage.setItem("focusStats", JSON.stringify(updated));

    // reward
    setXP(prev => (prev || 0) + 5);
addProductiveTime(focusDuration || 60, "Focus Session");
    // auto-start break (5 min)
    startBreak(5);

    // small notification
    setTimeout(() => alert("‚ú® Focus session complete! +5 XP. Break started (5 min)."), 200);
  } else {
    // early abort ‚Üí punishment using your existing flow
    const randomPunishment = normalPunishments[Math.floor(Math.random() * normalPunishments.length)];
    addPunishment({
      type: "focusBreak",
      text: `You broke focus early!\nPunishment: ${randomPunishment}`,
      deathMode: false
    });

    // ü©∏ increase debt & fog when focus broken
    setDebt(prev => (prev || 0) + 5);
    setFogLevel(prev => (prev || 0) + 5);

    // optional alert or toast
    setTimeout(() => alert("‚ö†Ô∏è Focus broken early! +5 Debt, +5 Fog."), 300);
  }

  // reset local focus fields
  setFocusStartTime(null);
  setFocusDuration(0);
  setFocusRemaining(0);
}
  


 function startBreak(minutes) {
  setOnBreak(true);
  setBreakRemaining(minutes * 60);
  const endTime = Date.now() + minutes * 60 * 1000;
  localStorage.setItem("breakSession", JSON.stringify({ active: true, endTime }));
}

useEffect(() => {
  let interval;
  if (onBreak && breakRemaining > 0) {
    interval = setInterval(() => {
      setBreakRemaining(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          finishBreak();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  }
  return () => clearInterval(interval);
}, [onBreak, breakRemaining]);

function finishBreak() {
  setOnBreak(false);
  localStorage.removeItem("breakSession");
  setBreakRemaining(0);
  setTimeout(() => alert("‚òï Break over ‚Äî back to work."), 200);
}

// restore focus or break on app load
useEffect(() => {
  // restore focus session if active
  try {
    const savedFocus = JSON.parse(localStorage.getItem("focusSession"));
    if (savedFocus && savedFocus.active) {
      const elapsedSec = Math.floor((Date.now() - savedFocus.start) / 1000);
      const remaining = savedFocus.duration * 60 - elapsedSec;
      if (remaining > 0) {
        setFocusActive(true);
        setFocusDuration(savedFocus.duration);
        setFocusRemaining(remaining);
      } else {
        localStorage.removeItem("focusSession");
      }
    }
  } catch (e) { /* ignore parse errors */ }

  // restore break if active
  try {
    const savedBreak = JSON.parse(localStorage.getItem("breakSession"));
    if (savedBreak && savedBreak.active) {
      const remaining = Math.ceil((savedBreak.endTime - Date.now()) / 1000);
      if (remaining > 0) {
        setOnBreak(true);
        setBreakRemaining(remaining);
      } else {
        localStorage.removeItem("breakSession");
      }
    }
  } catch (e) {}
}, []); // run once on mount 

  // -------------------- EMERGENCY SYSTEM --------------------
function triggerEmergencyDay() {
  if (emergencyUsed) return alert("‚ö†Ô∏è Emergency already used today!");
  // Optional monthly limit check:
  const log = JSON.parse(localStorage.getItem("emergencyLog") || "[]");
  const month = new Date().getMonth();
  const uses = log.filter(e => new Date(e.date).getMonth() === month).length;
  if (uses >= 2) {
    return alert("‚ö†Ô∏è You already used 2 emergency days this month.");
  }
  setShowEmergencyModal(true);
}

function confirmEmergencyDay() {
  const today = new Date().toLocaleDateString();

  // ‚úÖ Log this emergency
  const log = JSON.parse(localStorage.getItem("emergencyLog") || "[]");
  log.push({ date: today });
  localStorage.setItem("emergencyLog", JSON.stringify(log));

  // ‚úÖ Mark as used for today
  setEmergencyUsed(true);
  localStorage.setItem("emergencyUsed", "true");
  localStorage.setItem("emergencyDate", today);

  try {
    // === Nullify everything ===
    // Tasks
    setTasks([]);
    localStorage.setItem("tasks", JSON.stringify([]));

    // Contracts & Mocks
    localStorage.removeItem("activeContract");
    localStorage.removeItem("mockData");

    // Punishments
    localStorage.setItem("punishments", JSON.stringify([]));

    // Focus / Break sessions
    localStorage.removeItem("focusSession");
    localStorage.removeItem("breakSession");

    // Proof-related
    localStorage.removeItem("proofPending");

    // Optional fog/debt reset
    if (typeof setFog === "function") setFog(0);
    if (typeof setDebt === "function") setDebt(0);
  } catch (err) {
    console.error("Emergency reset failed:", err);
  }

  // üéÅ Reward +70 XP for surviving day
  setXP(prev => (prev || 0) + 70);

  // Close modal
  setShowEmergencyModal(false);

  alert("üö® Emergency Day declared! All features nullified, +70 XP awarded.");
  }
  
// ---- Start Challenge ----
function startChallenge(type, target, duration) {
  const base = { type, target, startDate: Date.now() };

  if (type === "streak") {
    setChallenge({ ...base, days: Array(target).fill(false) });
  } else if (type === "percentile") {
    setChallenge({
      ...base,
      logs: Array(target).fill({ score: null, passed: false }),
      duration: target, // validity = number of mocks
    });
  } else if (type === "tasks") {
    setChallenge({ ...base, progress: 0, duration });
  }
  setStatus("");
}
// ---- Delete Contract Manually ----
function deleteContract(id) {
  const updated = contracts.filter(c => c.id !== id);
  setContracts(updated);
  localStorage.setItem("shadowContracts", JSON.stringify(updated));
  }
// ---- Update Helpers ----
function markStreakDayComplete(i) {
  const updated = [...challenge.days];
  updated[i] = true;
  setChallenge({ ...challenge, days: updated });
}

function saveMockPercentile(i, score) {
  const logs = [...challenge.logs];
  logs[i] = { score, passed: score >= 90 };
  setChallenge({ ...challenge, logs });
}

function addOneTask() {
  setChallenge({ ...challenge, progress: challenge.progress + 1 });
}

// ---- Check Success ----
function checkChallengeComplete(challenge) {
  if (!challenge) return false;

  const now = Date.now();
  const oneDay = 24 * 60 * 60 * 1000;

  if (challenge.type === "streak") {
    const deadline = challenge.startDate + challenge.target * oneDay;
    if (now >= deadline) {
      return challenge.days.every((done) => done);
    }
  }

  if (challenge.type === "percentile") {
    return (
      challenge.logs.length > 0 &&
      challenge.logs.every((log) => log.passed === true)
    );
  }

  if (challenge.type === "tasks") {
    return challenge.progress >= challenge.target;
  }

  return false;
}

// ---- Check Fail ----
function checkChallengeFail(challenge) {
  if (!challenge) return false;

  const now = Date.now();
  const oneDay = 24 * 60 * 60 * 1000;

  if (challenge.type === "streak") {
    const deadline = challenge.startDate + challenge.target * oneDay;
    if (now >= deadline) {
      return !challenge.days.every((done) => done);
    }
  }

  if (challenge.type === "percentile") {
    const deadline = challenge.startDate + challenge.duration * oneDay;
    if (now >= deadline) {
      return !challenge.logs.every((log) => log.passed);
    }
  }

  if (challenge.type === "tasks") {
    const deadline = challenge.startDate + challenge.duration * oneDay;
    if (now >= deadline && challenge.progress < challenge.target) {
      return true;
    }
  }

  return false;
}

// ---- Auto Check ----
React.useEffect(() => {
  if (!challenge) return;
  const interval = setInterval(() => {
    if (checkChallengeComplete(challenge)) {
      setStatus("completed");
    } else if (checkChallengeFail(challenge)) {
      setStatus("failed");
    }
  }, 5000);
  return () => clearInterval(interval);
}, [challenge]);
  function handleUrgeComplete() {
  setShowUrgeModal(false);
  setXP(prevXP => prevXP + 3); // Reward +3 XP
}
  
  
function handleUrgeSkip() {
  setShowUrgeModal(false);
  setXP(prevXP => Math.max(0, prevXP - 5)); // -5 XP
  setRivalXP(prev => prev + 5); // Rival +5 XP
    }
  // === RELAPSE ===
  function handleRelapse(){
    if(confirm("Are you sure? Relapse will cost 50 XP!")){
      setXP(Math.max(0,xp-50));
    }
  }
  // Function to get character image element with glow for certain levels
function getCharacterForm(level) {
  const img = document.createElement("img");

  // Keep level in range 1-11
  if (level <= 0) level = 1;
  if (level >= 11) level = 11;

  img.src = characterImages[level - 1];

  // Add glow/aura for certain levels
  if ([4,6,8,10,11].includes(level)) {
    img.classList.add("glow");
  }

  return img;
}

  function getTaskRemainingTime(task) {
  if (!task.start || !task.end) return null;

  const now = new Date();
  const [startH, startM] = task.start.split(":").map(Number);
  const [endH, endM] = task.end.split(":").map(Number);

  const startTime = new Date();
  startTime.setHours(startH, startM, 0, 0);

  const endTime = new Date();
  endTime.setHours(endH, endM, 0, 0);

  if (now < startTime) {
    return `Starts at ${task.start}`;
  } else if (now >= startTime && now <= endTime) {
    const diff = endTime - now;
    const hrs = Math.floor(diff / (1000 * 60 * 60));
    const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const secs = Math.floor((diff % (1000 * 60)) / 1000);
    return `${hrs}h ${mins}m ${secs}s left`;
  } else {
    return "Expired!";
  }
  }
  
  function getRankInfo(level) {
  if (level < 5)  
    return {url: "https://static.thenounproject.com/png/4461072-512.png", color: "#A0A0A0"}; // E Rank (stone feel)
  if (level < 10) 
    return {url: "https://static.thenounproject.com/png/7507584-512.png", color: "#B0C4DE"}; // D Rank (steel/shield)
  if (level < 15) 
    return {url: "https://static.thenounproject.com/png/4385102-512.png", color: "#CD7F32"}; // C Rank (bronze)
  if (level < 20) 
    return {url: "https://static.thenounproject.com/png/4385101-512.png", color: "#C0C0C0"}; // B Rank (silver)
  if (level < 25) 
    return {url: "https://static.thenounproject.com/png/4385100-512.png", color: "#FFD700"}; // A Rank (gold)
  return {url: "https://static.thenounproject.com/png/4385099-512.png", color: "#FF4500"};     // S Rank (premium star)
  }
function getAuraColor(level) {
  if (level < 5) return "gray";     // E-Rank
  if (level < 10) return "blue";    // D-Rank
  if (level < 15) return "green";   // C-Rank
  if (level < 20) return "purple";  // B-Rank
  if (level < 25) return "gold";    // A-Rank
  return "red";                     // S-Rank
    }
  function logMockPercentile(percentile) {
  const today = new Date().toISOString().split("T")[0];
  const newEntry = { date: today, percentile: Number(percentile) };

  // üö´ If in grace period
  if (Date.now() < graceDeadline) {
    alert("üö´ No mock today! Grace Period Active. Revise wrong questions.");
    return;
  }

  // === Save / Replace Today's Log ===
  let updatedHistory = [...mockHistory];
  let lastEntry = updatedHistory[updatedHistory.length - 1];

  if (lastEntry && lastEntry.date === today) {
    // Replace today's log (update, no streak change again)
    updatedHistory[updatedHistory.length - 1] = newEntry;
  } else {
    // New day log
    updatedHistory.push(newEntry);
  }

  setMockHistory(updatedHistory);
  localStorage.setItem("mockHistory", JSON.stringify(updatedHistory));

  // === Check vs Best (only once per day) ===
  if (!lastEntry || lastEntry.date !== today) {
    // ‚úÖ New day streak calculation
    if (newEntry.percentile >= bestPercentile) {
      setBestPercentile(Math.max(bestPercentile, newEntry.percentile));
      localStorage.setItem("bestPercentile", Math.max(bestPercentile, newEntry.percentile));

      setFailStreak(0);
      localStorage.setItem("failStreak", 0);

      setXP((prev) => prev + 5);
      alert(`‚úÖ Great! You matched/beaten your best (${bestPercentile}%). +5 XP`);
    } else {
      const newFail = failStreak + 1;
      setFailStreak(newFail);
      localStorage.setItem("failStreak", newFail);

      if (newFail === 2) {
        // Punishment
        addPunishment({
          type: "mockTestFail",
          text: `‚ùå Two consecutive drops below ${bestPercentile}%. Punishment: ${
            deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)]
          }`,
          deathMode: true
        });

        // Start 2-day grace
        const deadline = Date.now() + 2 * 24 * 60 * 60 * 1000;
        setGraceDeadline(deadline);
        localStorage.setItem("graceDeadline", deadline);
        alert("‚ö†Ô∏è Grace started: Next 2 days = No Mock, only revision!");
      }
    }
  } else {
    // ‚úÖ Same day update ‚Üí no streak change
    alert(`‚ÑπÔ∏è Today's log updated to ${newEntry.percentile}%.`);
  }
  }
  

  function getRemainingDays(task) {
  if (task.type !== "timed") return null;

  const createdDate = new Date(task.created);
  const deadline = new Date(createdDate);
  deadline.setDate(createdDate.getDate() + parseInt(task.days || 0));

  const diffTime = deadline - new Date();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays > 0 ? `${diffDays} days left` : "Expired!";
      }
  // === BOSS TIMER ===
  function startBossTimer(hours){
    const endTime=Date.now()+hours*60*60*1000;
    localStorage.setItem('bossEndTime',endTime);
    setTimer(endTime-Date.now());
  }
  function checkTaskDeadlines() {
  const now = new Date();
  let updatedTasks = [...tasks];

  updatedTasks.forEach((task, idx) => {
    // only consider incomplete tasks
    if (task.completed) return;

    if (task.type === 'daily') {
      const [endH, endM] = task.end.split(':').map(Number);
      const endTime = new Date();
      endTime.setHours(endH, endM, 0, 0);

      if (now > endTime) {
        // if proof already submitted, ignore
        if (task.proof || task.completed) return;

        // if we've already started proofPending for this task, ensure modal or timeout exists
        if (!task.proofPending) {
          // mark proof pending with timestamp
          updatedTasks[idx] = { ...task, proofPending: true, missedAt: Date.now() };
          // open modal for the first missed one right away
          // but only open modal if no other modal is visible
          if (!showProofModal) {
            setProofTask(updatedTasks[idx]);
            setShowProofModal(true);
            // start grace timeout
            startProofTimeout(updatedTasks[idx]);
          }
        } else {
          // if proofPending exists already but no modal shown, show it (app reopened later)
          if (!showProofModal) {
            setProofTask(updatedTasks[idx]);
            setShowProofModal(true);
            // ensure a timeout exists (maybe app reopened after restart)
            ensureProofTimeout(updatedTasks[idx]);
          }
        }
      }
    } else if (task.type === 'timed') {
      // original logic: deadline = created + days
      const createdDate = new Date(task.created);
      const deadline = new Date(createdDate);
      deadline.setDate(createdDate.getDate() + parseInt(task.days || 0 || 0));
      if (now > deadline) {
        if (task.proof || task.completed) return;

        if (!task.proofPending) {
          updatedTasks[idx] = { ...task, proofPending: true, missedAt: Date.now() };
          if (!showProofModal) {
            setProofTask(updatedTasks[idx]);
            setShowProofModal(true);
            startProofTimeout(updatedTasks[idx]);
          }
        } else {
          if (!showProofModal) {
            setProofTask(updatedTasks[idx]);
            setShowProofModal(true);
            ensureProofTimeout(updatedTasks[idx]);
          }
        }
      }
    }
  });

  // save tasks back (only if something changed)
  setTasks(updatedTasks);
  localStorage.setItem('tasks', JSON.stringify(updatedTasks));
  }
  function getRemainingBossTime(){
    const endTime=parseInt(localStorage.getItem('bossEndTime'))||0;
    const now=Date.now();
    return Math.max(0,endTime-now);
  }
  function formatTime(ms){
    const totalSeconds=Math.floor(ms/1000);
    const hrs=Math.floor(totalSeconds/3600);
    const mins=Math.floor((totalSeconds%3600)/60);
    const secs=totalSeconds%60;
    return `${hrs}h ${mins}m ${secs}s`;
  }
const [taskTimers, setTaskTimers] = useState({});

useEffect(() => {
  const interval = setInterval(() => {
    let updatedTimers = {};
    tasks.forEach(task => {
      updatedTimers[task.id] = getTaskRemainingTime(task);
    });
    setTaskTimers(updatedTimers);
  }, 1000);

  return () => clearInterval(interval);
}, [tasks]);

  useEffect(() => {
  const checkAnchor = () => {
    const now = new Date();
    const minutesNow = now.getHours() * 60 + now.getMinutes();

    anchorTimes.forEach(a => {
      const [h, m] = a.time.split(":").map(Number);
      const anchorMinutes = h * 60 + m;

      if (Math.abs(minutesNow - anchorMinutes) <= 2) {
        // only trigger once per anchor per day
        if (!anchorsDone[a.id]) showAnchorPopup(a);
      }
    });
  };

  const interval = setInterval(checkAnchor, 60 * 1000);
  return () => clearInterval(interval);
}, [anchorsDone]);
  useEffect(() => {
  const interval = setInterval(() => {
    const now = new Date();
    if (now.getHours() === 0 && now.getMinutes() === 0) {
      setAnchorsDone({});
      localStorage.removeItem("anchorsDone");
    }
  }, 60 * 1000);

  return () => clearInterval(interval);
}, []);

useEffect(() => {
  const checkMissedAnchors = () => {
    const now = new Date();
    const minutesNow = now.getHours() * 60 + now.getMinutes();

    anchorTimes.forEach(a => {
      const [h, m] = a.time.split(":").map(Number);
      const anchorMinutes = h * 60 + m;

      // Trigger if time passed and not answered today
      if (minutesNow > anchorMinutes && (!anchorsDone[a.id] || anchorsDone[a.id] === "")) {
        showAnchorPopup(a);
      }
    });
  };

  // run 2 sec after open
  const timer = setTimeout(checkMissedAnchors, 2000);

  // also recheck every 10 min (in case app minimized)
  const interval = setInterval(checkMissedAnchors, 10 * 60 * 1000);

  return () => {
    clearTimeout(timer);
    clearInterval(interval);
  };
}, [anchorsDone]);

  useEffect(() => {
  // existing app-start code ...
  checkTaskDeadlines();

  // üßπ clean up old proof images automatically
  autoCleanOldProofs(5);
}, []);


  useEffect(() => {
  let interval;
  if (focusActive && focusRemaining > 0) {
    interval = setInterval(() => {
      setFocusRemaining(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          endFocusSession(true); // success
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  }
  return () => clearInterval(interval);
}, [focusActive, focusRemaining]);

  useEffect(() => {
  const today = new Date().toLocaleDateString();
  const last = localStorage.getItem("emergencyDate");
  if (last !== today) {
    setEmergencyUsed(false);
    localStorage.setItem("emergencyUsed", "false");
  }
}, []);

  // === Shadow Contract / Anchor Scheduler ===
useEffect(() => {
  const todayKey = new Date().toDateString();
  const lastReset = localStorage.getItem("lastAnchorReset");
  let anchorsDone = JSON.parse(localStorage.getItem("anchorsDone") || "{}");

  // üîÑ reset each new day
  if (lastReset !== todayKey) {
    anchorsDone = {};
    localStorage.setItem("anchorsDone", JSON.stringify(anchorsDone));
    localStorage.setItem("lastAnchorReset", todayKey);
  }

  const checkAnchors = () => {
    const now = new Date();
    const current = now.toTimeString().slice(0, 5); // "HH:MM"

    anchorTimes.forEach(a => {
      if (current === a.time && !anchorsDone[a.id]) {
        if (showArchitect) return; // don't overlap Architect modal
        console.log("‚è≥ Opening anchor:", a.label);
        openAnchorModal(a);
        anchorsDone[a.id] = true;
        localStorage.setItem("anchorsDone", JSON.stringify(anchorsDone));
      }
    });
  };

  checkAnchors();
  const interval = setInterval(checkAnchors, 60 * 1000);
  return () => clearInterval(interval);
}, [showArchitect]);
React.useEffect(() => {
  const today = new Date().toDateString();
  const savedDay = localStorage.getItem("lastQuestionDay");

  if (savedDay !== today) {

    if (localStorage.getItem("questionDone") !== "true") {
      setXP(prev => Math.max(0, prev - 5));
      increaseDebt(5);
    }

    setDailyQuestion("");
    setDailyAnswer("");
    setQuestionDone(false);

    localStorage.setItem("dailyQuestion", "");
    localStorage.setItem("dailyAnswer", "");
    localStorage.setItem("questionDone", "false");
    localStorage.setItem("lastQuestionDay", today);

    setLastQuestionDay(today);
  }
}, []);
  // ==========================================================
// ‚è±Ô∏è JOURNAL OF RESOLVE - EFFECTS
// ==========================================================

React.useEffect(() => {
  // Load saved crystals from localStorage at app start
  loadCrystals();
}, []);
// === MOTIVATION SYSTEM (works even if app closed) ===
useEffect(() => {
  const now = Date.now();
  const lastTime = parseInt(localStorage.getItem("lastMotivationTime") || 0, 10);

  // Agar 3 ghante ho gaye ya pehli baar hai ‚Üí naya message dikhado
  if (!lastTime || now - lastTime >= 3 * 60 * 60 * 1000) {
    const randomQuote = motivationalQuotes[Math.floor(Math.random() * motivationalQuotes.length)];
    setMotivationText(randomQuote);
    setShowMotivation(true);
    localStorage.setItem("lastMotivationTime", String(now));
  }
}, []);

useEffect(() => {
  function resetHabits() {
    const today = new Date().toDateString();
    setHabits(prev => {
      const updated = prev.map(h => ({
        ...h,
        done: false,
        lastReset: today,
      }));
      localStorage.setItem("habits", JSON.stringify(updated));
      return updated;
    });
    console.log("‚ôªÔ∏è Habits reset at midnight:", today);
  }

  const now = new Date();
  const millisTillMidnight = 
    new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 5) - now;

  const midnightTimeout = setTimeout(() => {
    resetHabits();
    // Interval ka ref store karna zaroori hai
    intervalRef.current = setInterval(resetHabits, 24 * 60 * 60 * 1000);
  }, millisTillMidnight);

  return () => {
    clearTimeout(midnightTimeout);
    if (intervalRef.current) clearInterval(intervalRef.current);
  };
}, []);

  // DAILY midnight check and also run immediate on load
useEffect(() => {
  function checkContractsForDayMissesAndExpire() {
    const now = Date.now();
    let updated = [...contracts];
    let changed = false;

    updated = updated.map(c => {
      if (c.done || c.failed) return c;

      // Calculate day index
      const dayIndexNow = Math.floor((now - c.start) / (24 * 60 * 60 * 1000));
      const yesterdayIndex = dayIndexNow - 1;

      // ‚ö†Ô∏è Missed Yesterday Logging
      if (
        yesterdayIndex >= 0 &&
        c.progress[yesterdayIndex] === false &&
        !c.missNoted
      ) {
        setContractModalMessage(
          `‚ö†Ô∏è You missed logging progress for "${c.goal}" yesterday.\n\nü©∏ Debt +5 | XP -3`
        );
        setShowContractModal(true);

        increaseDebt(5);
        setXP(prev => Math.max(0, prev - 3));

        c.missNoted = true;
        changed = true;
      }

      // ‚ö∞Ô∏è Expiration Check
      if (now >= c.end) {
        const completedDays = c.progress.filter(Boolean).length;

        if (completedDays >= c.days) {
          // Completed Contract
          c = { ...c, done: true };

          setContractModalMessage(
            `‚úÖ Contract Completed!\n\n"${c.goal}" has been successfully finished.\n+10 XP | Fog -20`
          );
          setShowContractModal(true);

          setXP(prev => prev + 10);
          setFogLevel(prev => Math.max(0, prev - 20));
          changed = true;

        } else {
          // Failed Contract
          c = { ...c, failed: true };

          addPunishment({
            type: "contractFail",
            text: `üíÄ Contract failed: "${c.goal}"`,
            deathMode: true
          });

          setContractModalMessage(
            `üíÄ Contract Failed!\n\n"${c.goal}" was not completed in time.\nü©∏ Debt +10 | XP -10`
          );
          setShowContractModal(true);

          increaseDebt(10);
          setXP(prev => Math.max(0, prev - 10));
          changed = true;
        }
      }

      return c;
    });

    if (changed) {
      saveContracts(updated);
      handleContractsPostEnd(updated);
    }
  }

  // Run on app load
  checkContractsForDayMissesAndExpire();

  // Schedule next midnight + fallback every 6 hours
  const now = new Date();
  const millisTillMidnight =
    new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 5) - now;

  const midnightTimeout = setTimeout(() => {
    checkContractsForDayMissesAndExpire();
    setInterval(checkContractsForDayMissesAndExpire, 6 * 60 * 60 * 1000);
  }, millisTillMidnight);

  return () => clearTimeout(midnightTimeout);
}, [contracts]);
  
  
// === Decay System Effect ===
  useEffect(() => {
  const testMode = false;

  const today = new Date().toISOString().split('T')[0];
  const firstRun = localStorage.getItem('architectFirstRun');

  if (!firstRun) {
    // Pehli baar app chala, date save karo, report mat dikhayo
    localStorage.setItem('architectFirstRun', today);
    localStorage.setItem('lastArchitectCheck', today);
    return;
  }

  runArchitectDailyReport(testMode);
}, []);

  useEffect(() => {
    const savedPunishments = JSON.parse(localStorage.getItem("punishmentsTodayDetails") || "[]");
    if (savedPunishments.length > 0) {
        // Punishment text se p object bana ke state set karo
        setPunishments(savedPunishments.map(text => ({ text })));
    }
}, []);

  useEffect(() => {
  const now = new Date();
  const today = now.toISOString().split("T")[0];
  const lastLogDate = mockHistory.length > 0 ? mockHistory[mockHistory.length - 1].date : null;

  if (lastLogDate !== today && Date.now() > new Date().setHours(23,59,59,999)) {
    // Missed log
    const newFail = failStreak + 1;
    setFailStreak(newFail);
    localStorage.setItem("failStreak", newFail);

    if (newFail === 2) {
      addPunishment({
        type: "mockTestMiss",
        text: `‚ùå You missed logging 2 days in a row! Punishment: ${
          deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)]
        }`,
        deathMode: true
      });

      const deadline = Date.now() + 2 * 24 * 60 * 60 * 1000;
      setGraceDeadline(deadline);
      localStorage.setItem("graceDeadline", deadline);
      alert("‚ö†Ô∏è Grace started due to missed logs!");
    }
  }
}, [mockHistory]);
  
  // === Timer Update ===
  useEffect(()=>{
    const interval=setInterval(()=>{ setTimer(getRemainingBossTime()); },1000);
    return()=>clearInterval(interval);
  },[]);

  useEffect(() => {
  const interval = setInterval(checkTaskDeadlines, 30000); // check every 30 sec
  return () => clearInterval(interval);
}, [tasks]);

  
 useEffect(() => {
  const today = new Date();
  let lastDungeonDate = localStorage.getItem('lastDungeonDate');

  if (!lastDungeonDate) {
    localStorage.setItem('lastDungeonDate', today);
    lastDungeonDate = today;
  }

  const diffDays = Math.floor((today - new Date(lastDungeonDate)) / (1000 * 60 * 60 * 24));

  if (diffDays >= 10 && !punishments.some(p => p.type === 'dungeon')) {
    addPunishment({
      type: 'dungeon',
      text: "Dungeon Boss! Complete 20 tasks within 24 hrs!",
      deathMode: true
    });
    startBossTimer(24); // 24 hrs for challenge
    localStorage.setItem('lastDungeonDate', today);
    setTaskLog([]); // Reset log for tracking new tasks
  }
}, [punishments]);
  // === SAVE DATA ===
  useEffect(() => {
  localStorage.setItem('xp', xp);
  localStorage.setItem('level', level);
  localStorage.setItem('tasks', JSON.stringify(tasks));
  localStorage.setItem('habits', JSON.stringify(habits));
  localStorage.setItem('punishments', JSON.stringify(punishments));
  localStorage.setItem('bossCountdown', bossCountdown);
  localStorage.setItem('rivalXP', rivalXP);
  localStorage.setItem('rivalLevel', rivalLevel);
  localStorage.setItem('taskLog', JSON.stringify(taskLog));
  localStorage.setItem('behindDays', behindDays);
  localStorage.setItem('dailyQuestList', JSON.stringify(dailyQuestList));
  localStorage.setItem('wakeUpOnTime', JSON.stringify(wakeUpOnTime));   
  localStorage.setItem('mockPercentile', mockPercentile);           
    

  // Architect persistence
  localStorage.setItem('architectThreshold', String(architectThreshold));
  localStorage.setItem('architectPositiveStreak', String(architectPositiveStreak));
  localStorage.setItem('architectNegativeStreak', String(architectNegativeStreak));

  // XP start value (for daily XP calculation)
  if (!localStorage.getItem('xpStartValue')) {
    localStorage.setItem('xpStartValue', String(xp));
  }
    saveDailySummary();
}, [
  xp,
  level,
  tasks,
  habits,
  punishments,
  bossCountdown,
  rivalXP,
  rivalLevel,
  taskLog,
  behindDays,
  dailyQuestList,
  architectThreshold,
  architectPositiveStreak,
  architectNegativeStreak,
    wakeUpOnTime,          
  mockPercentile      
]);
  
useEffect(() => {
  localStorage.setItem('smallBossCount', smallBossCount);
}, [smallBossCount]);
  
  useEffect(() => {
  localStorage.setItem("shadowContracts", JSON.stringify(contracts));
  // also re-check whether UI should be locked/unlocked whenever contracts change
  ensureContractsActive(contracts);
}, [contracts]);
  
  // === LEVEL UP ===
  useEffect(()=>{
    if(xp>=getXPForLevel(level)){
      setXP(xp-getXPForLevel(level));
      setLevel(level+1);
      setShowLevelUp(true);
      setTimeout(()=>setShowLevelUp(false),2000);
    }
  },[xp]);

  useEffect(() => {
  if (selectedHistoryDay) {
    const timer = setTimeout(() => {
      setSelectedHistoryDay(null); // Modal close after 10s
    }, 10000); // 10000 ms = 10 seconds

    return () => clearTimeout(timer); // Cleanup if modal closes early
  }
}, [selectedHistoryDay]);
  
  useEffect(() => {
  const today = new Date().toDateString();
  setHabits(prev => {
    // Agar empty array ya pehla habit ho
    if (prev.length === 0) return prev;

    // Check karo lastReset
    const needsReset = prev.some(h => h.lastReset !== today);
    if (needsReset) {
      const updated = prev.map(h => ({
        ...h,
        done: false,
        lastReset: today,
      }));
      localStorage.setItem("habits", JSON.stringify(updated));
      console.log("‚ö° Immediate reset on app start:", today);
      return updated;
    }
    return prev;
  });
}, []);

  // Dopamine Detox System


const TOTAL_TIME_SEC = 2 * 60 * 60; // 2 hours
const DECREASE_PER_SEC = 100 / TOTAL_TIME_SEC;

// Helper: Update time string
function updateTimeRemainingFromLevel(level) {
  const secondsLeft = Math.floor((level / 100) * TOTAL_TIME_SEC);
  const hrs = String(Math.floor(secondsLeft / 3600)).padStart(2, "0");
  const mins = String(Math.floor((secondsLeft % 3600) / 60)).padStart(2, "0");
  const secs = String(secondsLeft % 60).padStart(2, "0");
  setTimeRemaining(`${hrs}:${mins}:${secs}`);
}

// === Daily Reset ===
useEffect(() => {
  const today = new Date().toLocaleDateString();
  const lastReset = localStorage.getItem("dopamineResetDate");

  if (lastReset !== today) {
    setDopamineLevel(100);
    localStorage.setItem("dopamineLevel", 100);
    localStorage.setItem("dopamineResetDate", today);
    setDopamineActive(false);
    updateTimeRemainingFromLevel(100);
  }
}, []);

  // Run an immediate check on app start to detect missed tasks and show modal
useEffect(() => {
  checkTaskDeadlines();

  // Also, for any tasks already with proofPending (e.g., saved before), show modal for the first one
  const pending = (tasks || []).find(t => t.proofPending && !t.proof && !t.completed);
  if (pending) {
    setProofTask(pending);
    setShowProofModal(true);
    ensureProofTimeout(pending);
  }
}, []); // run once on mount

// === Toggle Logic ===
useEffect(() => {
  localStorage.setItem("dopamineActive", JSON.stringify(dopamineActive));

  if (dopamineActive) {
    const storedLevel = parseFloat(localStorage.getItem("dopamineLevel")) || 100;
    updateTimeRemainingFromLevel(storedLevel);

    if (storedLevel <= 0) {
      setDopamineActive(false);
      alert("‚ö†Ô∏è Dopamine depleted! Apply punishment now!");
      addPunishment({
        type: "dopamineFail",
        text: "Dopamine Bar Empty! Punishment: Solve 100 questions + No social media 6 hrs",
        deathMode: true
      });
    }
  }
}, [dopamineActive]);

// === Timer Effect (Freeze Mode) ===
useEffect(() => {
  let interval;
  if (dopamineActive) {
    interval = setInterval(() => {
      setDopamineLevel(prev => {
        const newLevel = Math.max(prev - DECREASE_PER_SEC, 0);
        localStorage.setItem("dopamineLevel", newLevel);
        updateTimeRemainingFromLevel(newLevel);

        if (newLevel <= 0) {
          clearInterval(interval);
          setDopamineActive(false);
          alert("‚ö†Ô∏è Dopamine depleted! Apply punishment now!");
          addPunishment({
            type: "dopamineFail",
            text: "Dopamine Bar Empty! Punishment: Solve 100 questions + No social media 6 hrs",
            deathMode: true
          });
        }
        return newLevel;
      });
    }, 1000);
  }

  return () => clearInterval(interval); // üü¢ OFF hone pe turant band
}, [dopamineActive]);


  
  useEffect(() => {
  const today = new Date().toLocaleDateString();
  const lastFogReset = localStorage.getItem("fogReset");

  if (lastFogReset !== today) {
    setFogLevel(20);
    localStorage.setItem("fogReset", today);
  }
}, []);

  useEffect(() => {
  localStorage.setItem("fogLevel", fogLevel);
}, [fogLevel]);
  
  useEffect(() => {
  // Fog level penalty/reward at end of day
  const today = new Date().toLocaleDateString();
  const lastCheck = localStorage.getItem("fogDate");
  if (lastCheck !== today) {
    if (fogLevel > 70) {
      setXP(prev => Math.max(0, prev - 5));
      // NEW: Add debt if fog high
      increaseDebt(5);
    } else if (fogLevel < 30) {
      setXP(prev => prev + 5);
    }
    localStorage.setItem("fogDate", today);
  }
}, []);


  // === Architect Daily Check Trigger ===
useEffect(() => {
  const todayKey = new Date().toDateString();
  const lastCheck = localStorage.getItem("lastArchitectCheck");

  // Run once per calendar day only when app first opens
  if (lastCheck !== todayKey) {
    setTimeout(() => {
      // Step 1: Pre-announcement
      showArchitectModal("üïõ The Architect has arrived to judge your day...", "neutral");

      // Step 2: Close first modal and then run main report
      setTimeout(() => {
        closeArchitectModal(); // close the neutral modal
        setTimeout(() => {
          console.log("Architect report running for", todayKey);
          runArchitectDailyReport(); // main judgment
        }, 800);
      }, 3500);
    }, 1500);
  }
}, []);

  
useEffect(() => {
  const today = new Date().toISOString().split("T")[0];
  const lastReset = localStorage.getItem("productivityDate");

  // 1Ô∏è‚É£ Daily reset if date changed
  if (lastReset !== today) {
    localStorage.setItem("productivityDate", today);
    localStorage.setItem("productiveMinutes", "0");
    localStorage.setItem("wastageMinutes", "0");
    localStorage.setItem("manualActivities", JSON.stringify([])); // optional clear log
    console.log("üîÑ Daily productivity reset complete");
  }

  // 2Ô∏è‚É£ Load stored values (after reset if any)
  const prod = Number(localStorage.getItem("productiveMinutes") || 0);
  const waste = Number(localStorage.getItem("wastageMinutes") || 0);
  setProductiveMinutes(prod);
  setWastageMinutes(waste);
}, []);
  
  // Boss Fight Check
useEffect(() => {
  // === Small Boss after 7 tasks ===
  if (bossCountdown >= 6 && !punishments.some(p => p.type === 'smallBoss')) {
  addPunishment({
    type: 'smallBoss',
    text: "Small Boss Fight! Complete within 3 hrs!",
    deathMode: true
  });
  startBossTimer(3);

  // Small boss streak increase
  setSmallBossCount(prev => {
    const newCount = prev + 1;
    if (newCount >= 10) {
      // Trigger Dungeon Boss after 10 small bosses
      addPunishment({
        type: 'dungeon',
        text: "Dungeon Boss! Complete 20 tasks within 24 hrs!",
        deathMode: true
      });
      startBossTimer(24);
      localStorage.setItem('lastDungeonDate', new Date().toISOString());
      return 0; // reset streak
    }
    return newCount;
  });

  setBossCountdown(0);
    }
  

  // === Weekly Boss every Sunday ===
  const today = new Date().getDay();
  if (today === 0 && localStorage.getItem('weeklyBossTriggered') !== 'true') {
  const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
  addPunishment({
    type: 'weeklyBoss',
    text: `Dont die until its Complete within 10 hrs!\nPunishment: ${randomDeathPunishment}`,
    deathMode: true
  });
  startBossTimer(10); // 10 hrs timer
  localStorage.setItem('weeklyBossTriggered', 'true');
  }
  if (today !== 0) {
    localStorage.setItem('weeklyBossTriggered', 'false');
  }


}, [bossCountdown, taskLog]);

  useEffect(() => {
  const interval = setInterval(() => {
    const remaining = getRemainingBossTime();
    setTimer(remaining);

    if (remaining <= 0 && punishments.length > 0) {
      const current = punishments[0];
      if (['boss', 'weeklyBoss', 'dungeon'].includes(current.type)) {
        // Boss failed
        setXP(Math.max(0, xp - 30)); // Penalty
        setRivalXP(prev => prev + 20); // Rival advantage
        // NEW: Add debt when punishment fails
    increaseDebt(10);
        completePunishment(); // Remove boss punishment
      }
    }
  }, 1000);
  return () => clearInterval(interval);
}, [punishments]);

  // === Rival XP Auto Update ===
// === Rival XP Auto Update ===
const DAILY_RIVAL_XP = 70;

// ‚úÖ Auto level-up fix
useEffect(() => {
  let xp = rivalXP;
  let lvl = rivalLevel;
  let changed = false;

  while (xp >= getXPForLevel(lvl)) {
    xp -= getXPForLevel(lvl);
    lvl++;
    changed = true;
  }

  if (changed) {
    setRivalXP(xp);
    setRivalLevel(lvl);
    localStorage.setItem("rivalXP", String(xp));
    localStorage.setItem("rivalLevel", String(lvl));
  }
}, [rivalXP, rivalLevel]);

// ‚úÖ Safe daily XP system
useEffect(() => {
  const giveDailyRivalXP = () => {
    setRivalXP(prev => {
      const newXP = prev + DAILY_RIVAL_XP;
      localStorage.setItem("rivalXP", String(newXP));
      localStorage.setItem("lastRivalUpdate", String(Date.now()));
      return newXP;
    });
  };

  const lastUpdate = parseInt(localStorage.getItem("lastRivalUpdate") || "0", 10);
  const todayMidnight = new Date();
  todayMidnight.setHours(0, 0, 0, 0);

  // ‚úÖ Step 1: Give XP once per real day
  if (lastUpdate < todayMidnight.getTime()) {
    giveDailyRivalXP();
  }

  // ‚úÖ Step 2: Schedule one XP add at next midnight (no intervals)
  const now = new Date();
  const millisTillMidnight =
    new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0) - now;

  const midnightTimeout = setTimeout(() => {
    giveDailyRivalXP(); // add XP once at midnight
  }, millisTillMidnight);

  return () => clearTimeout(midnightTimeout);
}, []);

  
  useEffect(() => {
  const now = Date.now();
  const lastCheck = parseInt(localStorage.getItem('last3DayCheck')) || 0;
  const diffDays = Math.floor((now - lastCheck) / (1000 * 60 * 60 * 24));

  if (diffDays >= 3) {
    // Update last check date
    localStorage.setItem('last3DayCheck', now);

    // Check if rival is ahead
    const rivalAhead = rivalLevel > level || (rivalLevel === level && rivalXP > xp);

    if (rivalAhead) {
      const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
      addPunishment({
        type: 'deathRival',
        text: `Rival is ahead after 3 days! Punishment: ${randomDeathPunishment}`,
        deathMode: true
      });
    }
  }
}, [xp, level, rivalXP, rivalLevel]);

  // === Wake Up System ===
const [goalWakeUp, setGoalWakeUp] = useState(localStorage.getItem("goalWakeUp") || "07:00");
const [wakeUpTime, setWakeUpTime] = useState(localStorage.getItem("wakeUpTime") || null);
const [wakeUpLoggedToday, setWakeUpLoggedToday] = useState(localStorage.getItem("wakeUpLoggedToday") === new Date().toDateString());

function logWakeUp() {
  if (wakeUpLoggedToday) {
    alert("‚úÖ Already logged today!");
    return;
  }

  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const timeStr = `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}`;

  setWakeUpTime(timeStr);
  localStorage.setItem("wakeUpTime", timeStr);
  localStorage.setItem("wakeUpLoggedToday", new Date().toDateString());

  // compare with goal
  const [goalH, goalM] = goalWakeUp.split(":").map(Number);
  const goalDate = new Date();
  goalDate.setHours(goalH, goalM, 0, 0);

  if (now <= goalDate) {
    // ‚úÖ Mark success in state + storage
    setWakeUpOnTime(true);
    localStorage.setItem("wakeUpOnTime", "true");

    setXP((prev) => prev + 5);
    setFogLevel((prev) => Math.max(0, prev - 10));
    alert(
      `üåÖ Early wake up! Goal ${goalWakeUp}, You: ${timeStr}\n+5 XP, -10% Fog`
    );
  } else {
    // ‚ùå Mark fail in state + storage
    setWakeUpOnTime(false);
    localStorage.setItem("wakeUpOnTime", "false");

    setXP((prev) => Math.max(0, prev - 5));
    setFogLevel((prev) => Math.min(100, prev + 10));
    addPunishment({
      type: "lateWake",
      text: `‚è∞ You woke up late! Goal ${goalWakeUp}, You: ${timeStr}\nPunishment: Solve 50 questions or 20 push-ups`,
      deathMode: false,
    });
    alert(
      `‚ö†Ô∏è Late wake up! Goal ${goalWakeUp}, You: ${timeStr}\n-5 XP, +10% Fog`
    );
  }
  }

  // === Wake Up Auto Penalty Check (midnight reset style) ===
// === Wake Up Miss Punishment (Midnight Check Only, Once per Day) ===
useEffect(() => {
  const checkWakeUpMiss = () => {
    const today = new Date().toDateString();
    const storedLog = localStorage.getItem("wakeUpLoggedToday");
    const punishedDate = localStorage.getItem("wakeUpPunishedDate");

    // Agar pehli baar run hai (data hi nahi hai) ‚Üí skip
    if (!storedLog) {
      localStorage.setItem("wakeUpLoggedToday", "");
      return;
    }

    const wakeLogged = storedLog === today;

    // Sirf tab punishment do agar aaj ka log miss hai aur abhi punishment nahi diya gaya
    if (!wakeLogged && punishedDate !== today) {
      setXP(prev => Math.max(0, prev - 10));
      setFogLevel(prev => Math.min(100, prev + 15));
      addPunishment({
        type: "wakeUpMiss",
        text: "‚ö†Ô∏è You missed logging wake-up today!\nPunishment: -10 XP, +15% Fog",
        deathMode: false
      });

      // Mark punishment given for today
      localStorage.setItem("wakeUpPunishedDate", today);
    }

    // Next day ke liye wakeUpLoggedToday reset
    localStorage.setItem("wakeUpLoggedToday", "");
  };

  // Schedule at midnight only
  const now = new Date();
  const millisTillMidnight =
    new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 5) - now;

  const midnightTimeout = setTimeout(() => {
    checkWakeUpMiss();
    setInterval(checkWakeUpMiss, 24 * 60 * 60 * 1000);
  }, millisTillMidnight);

  return () => clearTimeout(midnightTimeout);
}, []);
  // === Daily Quest System ===
  useEffect(() => {
  const today = new Date().toDateString();
  const lastReset = localStorage.getItem('lastQuestReset');
  const todayIndex = new Date().getDay();
  if (lastReset !== today) {
    const resetQuests = (weeklyQuestExercises[todayIndex] || weeklyQuestExercises[0])
      .map(e => ({ title: e, done: false }));
    setDailyQuestList(resetQuests);
    localStorage.setItem('lastQuestReset', today);
    localStorage.setItem('dailyQuestList', JSON.stringify(resetQuests));
    setShowDailyQuest(true);

    // ‚¨ÖÔ∏è Flag reset
    localStorage.setItem('dailyQuestCompletedToday', 'false');
  } else {
    const saved = JSON.parse(localStorage.getItem('dailyQuestList')) || [];
    setDailyQuestList(saved);
    setShowDailyQuest(!saved.every(q => q.done));
  }
}, []);

  
function toggleQuestDone(index){
  const updated=[...dailyQuestList];
  updated[index].done=!updated[index].done;
  setDailyQuestList(updated);
  localStorage.setItem('dailyQuestList',JSON.stringify(updated));

  if(updated.every(q=>q.done)){
    // Quest complete hone ka flag save karo
    localStorage.setItem('dailyQuestCompletedToday', 'true');

    setShowDailyQuest(false);
    setXP(xp+10);
  }
}
  function failDailyQuest(){
  setShowDailyQuest(false);
  const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
  addPunishment({
    type: 'questFail',
    text: `Daily Quest Failed! Punishment: ${randomDeathPunishment}`,
    deathMode: true
  });
    // NEW: Add debt on quest fail
  increaseDebt(7);
  }
// === Debt Increase Helper ===
function increaseDebt(amount) {
  setDebt(prev => {
    const newDebt = Math.min(50, prev + amount); // cap at 50
    localStorage.setItem('debt', newDebt);
    return newDebt;
  });
  }
  
  // --- add this helper (place near increaseDebt / completePunishment helpers) ---
function gainXP(amount) {
  setXP(prev => {
    const next = prev + Number(amount || 0);
    localStorage.setItem('xp', next);
    return next;
  });
  }
// Persist debt whenever it changes (optional but recommended)
React.useEffect(() => {
  localStorage.setItem('debt', String(debt));
}, [debt]);

  function startProofTimeout(task) {
  // clear existing if any
  if (!task || !task.id) return;
  const id = task.id;

  // clear prior timeout if present
  if (proofTimeoutsRef.current[id]) {
    clearTimeout(proofTimeoutsRef.current[id]);
  }

  // schedule auto-fail after PROOF_GRACE_MS
  proofTimeoutsRef.current[id] = setTimeout(() => {
    handleProofTimeout(id);
  }, PROOF_GRACE_MS);
}

function ensureProofTimeout(task) {
  // If timeout already exists in ref, leave it. Otherwise compute remaining time based on missedAt.
  if (!task || !task.id) return;
  const id = task.id;

  if (proofTimeoutsRef.current[id]) return; // already set

  const missedAt = task.missedAt || Date.now();
  const elapsed = Date.now() - missedAt;
  const remaining = Math.max(0, PROOF_GRACE_MS - elapsed);

  proofTimeoutsRef.current[id] = setTimeout(() => {
    handleProofTimeout(id);
  }, remaining);
}

function handleProofTimeout(taskId) {
  // get latest tasks
  const curr = JSON.parse(localStorage.getItem('tasks') || '[]');
  const task = curr.find(t => t.id === taskId);
  if (!task) return;

  // if user already submitted proof or task completed in the meantime, do nothing
  if (task.proof || task.completed) {
    // cleanup timeout
    if (proofTimeoutsRef.current[taskId]) {
      clearTimeout(proofTimeoutsRef.current[taskId]);
      delete proofTimeoutsRef.current[taskId];
    }
    return;
  }

  // punishment: same format you used elsewhere
  const randomPunishment = normalPunishments[Math.floor(Math.random() * normalPunishments.length)];
  addPunishment({
    type: 'taskMissed',
    text: `You missed: ${task.title}\nPunishment: ${randomPunishment}`,
    deathMode: false
  });
  increaseDebt(5);

  // mark task as removed/expired to match old behavior (or you can keep it but mark expired)
  const updated = curr.map(t => t.id === taskId ? { ...t, expired: true } : t).filter(t => !t.expired);
  // save updated: remove expired like old behavior
  setTasks(updated);
  localStorage.setItem('tasks', JSON.stringify(updated));

  // cleanup timeout ref
  if (proofTimeoutsRef.current[taskId]) {
    clearTimeout(proofTimeoutsRef.current[taskId]);
    delete proofTimeoutsRef.current[taskId];
  }

  // close modal if it was open for this task
  if (proofTask && proofTask.id === taskId) {
    setShowProofModal(false);
    setProofTask(null);
    setProofText("");
    setProofImage(null);
  }
  }

  function submitProof() {
  if (!proofTask) return;
  if (!proofText.trim() && !proofImage) {
    alert("Please provide text or photo proof before submitting.");
    return;
  }

  // update tasks
  const updated = tasks.map(t => {
    if (t.id === proofTask.id) {
      return {
        ...t,
        proof: proofText.trim() ? proofText.trim() : "Photo proof uploaded",
        proofImage: proofImage || null,
        completed: true,
        proofPending: false,
        missedAt: t.missedAt || null
      };
    }
    return t;
  });

  setTasks(updated);
  localStorage.setItem('tasks', JSON.stringify(updated));

  // reward XP (tune amount as you like)
  setXP(prev => (prev || 0) + 5);

  // cleanup modal & timeout
  if (proofTimeoutsRef.current[proofTask.id]) {
    clearTimeout(proofTimeoutsRef.current[proofTask.id]);
    delete proofTimeoutsRef.current[proofTask.id];
  }

  setShowProofModal(false);
  setProofTask(null);
  setProofText("");
  setProofImage(null);
}

function skipProofAndPunish() {
  if (!proofTask) {
    setShowProofModal(false);
    return;
  }
  // immediate punishment same as timeout
  const randomPunishment = normalPunishments[Math.floor(Math.random() * normalPunishments.length)];
  addPunishment({
    type: 'taskMissed',
    text: `You missed: ${proofTask.title}\nPunishment: ${randomPunishment}`,
    deathMode: false
  });
  increaseDebt(5);

  // remove task (mimic previous behavior)
  const updated = tasks.filter(t => t.id !== proofTask.id);
  setTasks(updated);
  localStorage.setItem('tasks', JSON.stringify(updated));

  // clear timeout
  if (proofTimeoutsRef.current[proofTask.id]) {
    clearTimeout(proofTimeoutsRef.current[proofTask.id]);
    delete proofTimeoutsRef.current[proofTask.id];
  }

  setShowProofModal(false);
  setProofTask(null);
  setProofText("");
  setProofImage(null);
  }
  
// Calendar
function saveDailySummary() {
  const today = new Date().toISOString().split("T")[0];
  const history = JSON.parse(localStorage.getItem("history") || "[]");
  const latestMock =
  mockHistory.length > 0 ? mockHistory[mockHistory.length - 1].percentile : 0;

  // Calculate XP gained today from xpStartValue
  const xpStartValue = parseInt(localStorage.getItem('xpStartValue')) || xp;
  const xpGainedToday = Math.max(0, xp - xpStartValue);
  const newEntry = {
    date: today,
    xp,
    xpGainedToday, // üîπ for Architect's "XP today" check
    level,
    fogLevel,
    dailyQuestCompleted: localStorage.getItem("dailyQuestCompletedToday") === "true",
    punishments: punishments.length,
    punishmentDetails: punishments.map(p => p.text),
    tasksCompleted: taskLog,
    relapseHua: relapseHua, // üîπ store relapse status
    dopamineActive: dopamineActive, // üîπ store dopamine toggle
    dopamineLevel: dopamineLevel, // üîπ store dopamine level %
wakeUpOnTime: localStorage.getItem("wakeUpOnTime") === "true",
  mockPercentile: latestMock || 0

  };

  const existingIndex = history.findIndex(h => h.date === today);
  if (existingIndex >= 0) {
    history[existingIndex] = newEntry;
  } else {
    history.push(newEntry);
  }

  localStorage.setItem("history", JSON.stringify(history));

  // Reset xpStartValue for tomorrow's calculation
  localStorage.setItem('xpStartValue', String(xp));
}

useEffect(() => {
  if (sessionStorage.getItem("punishmentCleared") === "true") return;

  const saved = JSON.parse(localStorage.getItem("punishments")) || [];
  setPunishments(saved);
}, []); // ‚úÖ Only run once
  
 function handlePunishmentAction(index, action) {
  const updated = [...punishments];
  const p = updated[index];

  if (!p || !p.text) return;

  // Helper: close modal safely
  const closeModal = () => {
    setPunishments([]);
    localStorage.setItem("punishments", JSON.stringify([]));
    if (typeof setShowPunishmentModal === "function") {
      setShowPunishmentModal(false);
    }
  };

  if (action === "complete") {
    // üîπ 1. Open manual duration modal first
    openDurationModal("Punishment", p.text);
    // üîπ 2. Store index temporarily so we can link it later
    localStorage.setItem("pendingPunishmentIndex", index);

    // ‚ö†Ô∏è Don‚Äôt immediately clear punishment yet ‚Äî wait until user saves time.
    // So comment out these 3 lines ‚Üì
    // updated.splice(index, 1);
    // setPunishments(updated);
    // localStorage.setItem("punishments", JSON.stringify(updated));

    // ‚öôÔ∏è Optionally, mark contract completions right away (keep this)
    if (p.text.toLowerCase().includes("daily log for")) {
      try {
        const contracts = JSON.parse(localStorage.getItem("shadowContracts")) || [];
        const updatedContracts = contracts.map(c => {
          if (p.text.includes(c.goal)) {
            const dayIndex = Math.floor((Date.now() - c.start) / (24 * 60 * 60 * 1000));
            if (dayIndex >= 0 && dayIndex < c.days) {
              const newProg = [...c.progress];
              newProg[dayIndex] = true;
              return { ...c, progress: newProg };
            }
          }
          return c;
        });
        localStorage.setItem("shadowContracts", JSON.stringify(updatedContracts));
        setContracts(updatedContracts);
        alert("‚úÖ Daily log marked complete for your contract!");
      } catch (err) {
        console.error("Contract update failed:", err);
      }
    } else {
      alert("‚è≥ Record duration to complete punishment!");
    }

    // üü¢ Close punishment modal only, not everything
    closeModal();
  }

  if (action === "forgive") {
    setXP(prev => Math.max(0, prev - 10));
    updated.splice(index, 1);
    setPunishments(updated);
    localStorage.setItem("punishments", JSON.stringify(updated));
    alert("‚öñÔ∏è Forgiven (-10 XP)");

    // üü¢ Force close modal after forgiveness
    closeModal();
  }
}


  // üïí Auto-clear Focus Stats at end of each day
(function clearOldFocusStats() {
  const today = new Date().toISOString().split("T")[0]; // e.g. "2025-11-11"
  const lastReset = localStorage.getItem("focusLastReset");

  if (lastReset !== today) {
    // New day ‚Üí clear stats
    localStorage.removeItem("focusStats");
    localStorage.setItem("focusLastReset", today);
    console.log("üßπ Focus Stats cleared for a new day");
  }
})();
  
  // === Add / Complete Tasks ===
  function addPunishment(p){
    setPunishments([...punishments,p]);
    setLockdown(true);
}
  function completePunishment(){
    const [first, ...rest] = punishments;
    let gain = 0;

    if(first.type === 'boss' || first.type === 'smallBoss') gain = 4;
    if(first.type === 'weeklyBoss') gain = 10;
    if(first.type === 'dungeon') gain = 20;

    setXP(xp + gain);

    if(['boss','smallBoss','weeklyBoss','dungeon'].includes(first.type)){
        setRivalXP(prev => prev + Math.floor(gain / 2));
    }

    if(first.deathMode){
        alert(`Reward: ${rewards[Math.floor(Math.random() * rewards.length)]}`);
    }

    setPunishments(rest);
    if(rest.length === 0) setLockdown(false);
  }

  function forgivePunishment() {
  const current = punishments[0];
  let penalty = current.deathMode ? 25 : 10; // DeathMode = 25 XP, Normal = 10 XP

  // Subtract XP but not below 0
  setXP(prevXP => Math.max(0, prevXP - penalty));

  // Rival gains XP equal to penalty
  setRivalXP(prev => prev + penalty);

      // NEW: Add debt when forgiving punishment
  increaseDebt(3);

  // Remove punishment without giving reward
  const [, ...rest] = punishments;
  setPunishments(rest);

  // If no punishments left, disable lockdown
  if (rest.length === 0) setLockdown(false);
}

  function addTask(){
    if(!newTask.title)return;
    const id=Date.now();
    const task={...newTask,id,done:false,created:new Date().toISOString()};
    if(newTask.type==='habit'){setHabits([...habits,task]);}
    else{setTasks([...tasks,task]);}
    setShowAddModal(false);
    setNewTask({type:'daily',title:'',start:'',end:'',days:''});
  }

function completeTask(id) {
  const completedTask = tasks.find(t => t.id === id);

  // auto mark contracts
  autoMarkContractsForGoal(completedTask.title);

  // remove from active list
  setTasks(tasks.filter(t => t.id !== id));
  setXP(xp + 2);

  // ‚úÖ Add productive minutes for completed task
  // If your tasks have a stored duration, use that; otherwise default 60 min
  const minutes = completedTask.duration || 60;
  addProductiveTime(minutes, "Daily Task");

  // Add to task log (for small boss reference)
  const updatedLog = [...taskLog, completedTask.title].slice(-7); // Keep only last 7
  setTaskLog(updatedLog);

  // If Dungeon Boss active, still track separately for 20-task logic
  if (punishments.some(p => p.type === 'dungeon')) {
    if (updatedLog.length >= 20) {
      completePunishment(); // Dungeon Boss Cleared
    }
  }

  setBossCountdown(bossCountdown + 1);
  handleTaskCompletion();
  }
  
  function completeHabit(id){
    const updated=habits.map(h=>h.id===id?{...h,done:true}:h);
    setHabits(updated);
    setXP(xp+1);
  }

  function deleteHabit(id){setHabits(habits.filter(h=>h.id!==id));}
//artictect 
  function showArchitectModal(message, mood) {
  setArchitectMessage(message);
  setArchitectMood(mood);
  setShowArchitect(true);
}

function closeArchitectModal() {
  setShowArchitect(false);
}

// call this to adjust threshold after streaks
function applyDynamicThreshold() {
  // Increase / decrease and clamp 65-85
  if (architectPositiveStreak >= 3) {
    const next = Math.min(70, architectThreshold + 5);
    setArchitectThreshold(next);
    localStorage.setItem('architectThreshold', String(next));
    setArchitectPositiveStreak(0);
    localStorage.setItem('architectPositiveStreak', "0");
  } else if (architectNegativeStreak >= 3) {
    const next = Math.max(65, architectThreshold - 5);
    setArchitectThreshold(next);
    localStorage.setItem('architectThreshold', String(next));
    setArchitectNegativeStreak(0);
    localStorage.setItem('architectNegativeStreak', "0");
  }
}


function runArchitectDailyReport(testMode = false) {
  // ----- date keys -----
  const yesterdayDate = new Date();
  yesterdayDate.setDate(yesterdayDate.getDate() - 1);
  const yesterdayKey = yesterdayDate.toISOString().split("T")[0];
  const todayKey = new Date().toDateString();

  // stop if there is no history yet (first day)
  const history = JSON.parse(localStorage.getItem("history") || "[]");
  if (!Array.isArray(history) || history.length === 0) {
    console.log("Architect skipped: first day, no history yet.");
    return;
  }

  // check that yesterday actually exists in history
  const hasYesterday = history.some(h => h.date === yesterdayKey);
  if (!hasYesterday) {
    console.log("Architect skipped: no data for yesterday yet.");
    return;
  }
  // prevent duplicate runs in same day
  if (!testMode) {
    const last = localStorage.getItem("lastArchitectCheck");
    if (last === todayKey) return;
  }

  // ---------- load data ----------
  
  const prevDayData = history.find(h => h.date === yesterdayKey) || {};

  const xpToday =
    prevDayData.xpGainedToday ??
    (JSON.parse(localStorage.getItem("dailyXP") || "{}")[yesterdayKey] || 0);
  const fog =
    prevDayData.fogLevel ??
    parseInt(localStorage.getItem("fogLevel") || "0", 10);
  const dailyQuestDone = prevDayData.dailyQuestCompleted === true;
  const taskLogLocal = prevDayData.tasksCompleted || [];
  const relapse = !!prevDayData.relapseHua;
  const dopamineOn = !!prevDayData.dopamineActive;
  const dopamineLevel = parseFloat(prevDayData.dopamineLevel) || 0;

  // üß† Focus
  const focusStats = JSON.parse(localStorage.getItem("focusStats") || "[]");
  const yesterdayFocusCount = focusStats.filter(s => {
    if (!s.date) return false;
    const iso = new Date(s.date).toISOString().split("T")[0];
    return iso === yesterdayKey;
  }).length;

  // üß† Mock percentile improvement
  const mockHistory = JSON.parse(localStorage.getItem("mockHistory") || "[]");
  const yesterdayMocks = mockHistory.filter(m => m.date === yesterdayKey);
  const bestYesterday = yesterdayMocks.length
    ? Math.max(...yesterdayMocks.map(m => Number(m.percentile) || 0))
    : 0;
  const priorMocks = mockHistory.filter(m => m.date < yesterdayKey);
  const bestBefore = priorMocks.length
    ? Math.max(...priorMocks.map(m => Number(m.percentile) || 0))
    : 0;

  // üï∞ Wake-up
  const wakeLog = JSON.parse(localStorage.getItem("wakeUpLog") || "{}");
  const wokeUpOnTimeYesterday = !!wakeLog[yesterdayKey];

  // üí∞ Debt
  const debtVal = parseInt(localStorage.getItem("debt") || "0", 10);

  // ---------- individual scores (0‚Äì100 each) ----------
  const scores = [
    { name: "Focus sessions", val: Math.min(100, (yesterdayFocusCount / 2) * 100) },
    { name: "XP gained", val: Math.min(100, (xpToday / 55) * 100) },
    { name: "Fog control", val: fog <= 70 ? 100 : Math.max(0, 100 - (fog - 70)) },
    { name: "Debt control", val: debtVal <= 15 ? 100 : Math.max(0, 100 - (debtVal - 15) * 5) },
    { name: "Wake-up on time", val: wokeUpOnTimeYesterday ? 100 : 0 },
    { name: "Mock improvement", val: bestYesterday > bestBefore ? 100 : 0 },
    { name: "Daily quest", val: dailyQuestDone ? 100 : 0 },
    { name: "Tasks done", val: taskLogLocal.length > 0 ? 100 : 0 },
    { name: "No relapse", val: !relapse ? 100 : 0 },
    { name: "Detox level", val: !(dopamineOn && dopamineLevel < 80) ? 100 : 0 },
  ];

  const totalPercent =
    Math.round(scores.reduce((sum, s) => sum + s.val, 0) / scores.length);

  // ---------- reward / punishment ----------
  if (totalPercent >= 80) {
    // ‚úÖ reward path
    setArchitectPositiveStreak(prev => {
      const next = prev + 1;
      localStorage.setItem("architectPositiveStreak", String(next));
      return next;
    });
    setArchitectNegativeStreak(0);
    localStorage.setItem("architectNegativeStreak", "0");

    setXP(prev => {
      const next = prev + 5;
      localStorage.setItem("xp", next);
      return next;
    });
    setFogLevel(prev => Math.max(0, prev - 15));
    setDopamineLevel(prev => Math.min(100, prev + 10));

    // üéÅ Architect Crystal reward
if (totalPercent >= 85) {
  addArchitectCrystal("Excellent discipline day", 5);
} else if (totalPercent >= 70) {
  addArchitectCrystal("Stable consistency day", 2);
  }
    const msg =
      `‚úÖ Excellent Discipline!\nOverall Score: ${totalPercent}%\n` +
      `+5 XP, ‚àí15 Fog, +10 Dopamine.`;
    showArchitectModal(msg, "positive");
  } else {
    // üíÄ punishment path
    setArchitectNegativeStreak(prev => {
      const next = prev + 1;
      localStorage.setItem("architectNegativeStreak", String(next));
      return next;
    });
    setArchitectPositiveStreak(0);
    localStorage.setItem("architectPositiveStreak", "0");

    setXP(prev => {
      const next = Math.max(0, prev - 5);
      localStorage.setItem("xp", next);
      return next;
    });
    setFogLevel(prev => Math.min(100, prev + 15));
    setDebt(prev => {
      const next = (prev || 0) + 3;
      localStorage.setItem("debt", next);
      return next;
    });

    // pick a punishment
    const deathList =
      (Array.isArray(deathModePunishments) && deathModePunishments.length)
        ? deathModePunishments
        : (Array.isArray(punishments) ? punishments : []);
    const punishText = deathList.length
      ? deathList[Math.floor(Math.random() * deathList.length)]
      : "Do deep work for 2 hours";

    addPunishment({
      type: "architectPunish",
      text: `Architect's Judgment: ${punishText}`,
      deathMode: true,
    });

    const msg =
      `‚ö†Ô∏è Discipline Score: ${totalPercent}% (below 80%)\n` +
      `Punishment: ${punishText}\nü©∏ +3 Debt, XP ‚àí5, Fog +15.`;
    showArchitectModal(msg, "negative");
  }

  applyDynamicThreshold();
  localStorage.setItem("lastArchitectCheck", todayKey);
  localStorage.setItem(
    "architectLastReport",
    JSON.stringify({ date: yesterdayKey, score: totalPercent })
  );
}


  function HistoryCalendar({ debt, onSelectDay }) {
  const history = JSON.parse(localStorage.getItem("history") || "[]");

  return (
    <div className="p-4 bg-gray-900 rounded-lg mt-6">
      <h2 className="text-lg font-semibold mb-4 text-white">üìÖ History Calendar</h2>
      <div className="grid grid-cols-7 gap-2">
        {history.map(day => (
          <div
            key={day.date}
            onClick={() => onSelectDay(day)}
            className={`p-2 rounded-lg text-center text-xs cursor-pointer hover:scale-105 transition-transform duration-200 ${
              day.dailyQuestCompleted ? "bg-green-500" : "bg-red-500"
            }`}
          >
            <p className="font-bold">{day.date.slice(5)}</p>
            <p>XP: {day.xp}</p>
            <p>Fog: {day.fogLevel}%</p>
          </div>
        ))}
      </div>
    
      {/* Debt System UI */}
      <div className="mt-5 max-w-sm mx-auto bg-gray-900 p-5 rounded-xl shadow-lg text-center text-white">
        <h2 className="text-lg font-semibold mb-2">üí∞ Debt: {debt}</h2>
        <p className="text-sm text-gray-400 mb-3">Debt reduces your XP gains. Repay using tasks.</p>
        <button
          onClick={() => {
            if (debt > 0) {
              const randomTask = repaymentTasks[Math.floor(Math.random() * repaymentTasks.length)];
              setCurrentRepaymentTask(randomTask);
              setShowDebtModal(true);
            } else {
              alert("‚úÖ No debt to repay!");
            }
          }}
          className="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded shadow-md font-semibold"
        >
          Repay Debt
        </button>
      </div>

      {/* Debt Repayment Modal */}
      {showDebtModal && (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
          <div className="bg-gray-800 p-6 rounded-xl shadow-lg w-full max-w-sm text-center text-white relative">
            <button
              className="absolute top-2 right-2 text-gray-400 hover:text-white"
              onClick={() => setShowDebtModal(false)}
            >
              ‚úñ
            </button>
            <h3 className="text-xl font-bold mb-4">Debt Repayment Task</h3>
            <p className="mb-6">{currentRepaymentTask}</p>
          <button
  onClick={() => {
    // reduce debt and persist immediately
    setDebt(prev => {
      const newDebt = Math.max(0, prev - 5);
      localStorage.setItem('debt', String(newDebt));
      return newDebt;
    });

    // award XP
    gainXP(2);

    setShowDebtModal(false);
    alert("‚úÖ Debt reduced by 5!");
  }}
  className="bg-green-600 hover:bg-green-700 px-4 py-2 rounded shadow-md font-semibold w-full"
>
  Mark as Done (-5 Debt)
</button>
          </div>
        </div>
      )}

</div>
  );
}
  
  return (
    <div className={"p-4 max-w-md mx-auto bg-black bg-opacity-70 rounded-lg mt-4 shadow-lg "+(showLevelUp?'flash':'')}>
      {/* Header */}
      <header className="text-center mb-4">
        <div className="max-w-sm mx-auto p-5 bg-gray-900 rounded-xl shadow-lg text-center text-white">

<h1 style={{ display: "flex", alignItems: "center", gap: "10px" }}>
  SHADOW MONARCH
  <svg
    className="slow-glow"
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 512 512"
    fill="#ff0000"
  >
    <path d="M256 0L96 160l64 64L192 192l32 32L96 352l64 64L416 160 352 96 256 0z" />
  </svg>
  <button
  onClick={() => setShowSettings(true)}
  className="bg-purple-700 hover:bg-purple-800 px-3 py-2 rounded-md text-sm font-bold"
>
  ‚öôÔ∏è Settings
</button>
</h1>
<div className="mt-6 grid grid-cols-2 gap-4 text-center">
  <div className="bg-green-900/30 border border-green-500 p-4 rounded-2xl shadow-md">
    <h3 className="text-lg font-semibold text-green-300">Productive Time</h3>
    <p className="text-2xl font-bold text-green-400 mt-1">
      {productiveMinutes} min
    </p>
  </div>

  <div className="bg-red-900/30 border border-red-500 p-4 rounded-2xl shadow-md">
    <h3 className="text-lg font-semibold text-red-300">Wasted Time</h3>
    <p className="text-2xl font-bold text-red-400 mt-1">
      {wastageMinutes} min
    </p>
  </div>
</div>

<div className="mt-4 text-center space-y-4">

  {/* üîπ Tracked Efficiency (as before) */}
  <div>
    <div className="flex justify-between text-sm text-gray-400 mb-1">
      <span>Tracked Efficiency</span>
      <span>
        {productiveMinutes + wastageMinutes > 0
          ? Math.round((productiveMinutes / (productiveMinutes + wastageMinutes)) * 100)
          : 0}%
      </span>
    </div>
    <div className="w-full bg-gray-700 h-3 rounded-full overflow-hidden">
      <div
        className="bg-gradient-to-r from-green-500 to-green-300 h-3 transition-all duration-500"
        style={{
          width: `${
            productiveMinutes + wastageMinutes > 0
              ? (productiveMinutes / (productiveMinutes + wastageMinutes)) * 100
              : 0
          }%`,
        }}
      />
    </div>
  </div>

  {/* üîπ Daily Efficiency (18h awake) */}
  <div>
    <div className="flex justify-between text-sm text-gray-400 mb-1">
      <span>Daily Efficiency (18h awake)</span>
      <span>
        {productiveMinutes > 0
          ? ((productiveMinutes / (18 * 60)) * 100).toFixed(1)
          : 0}%
      </span>
    </div>
    <div className="w-full bg-gray-700 h-3 rounded-full overflow-hidden">
      <div
        className="bg-gradient-to-r from-blue-500 to-blue-300 h-3 transition-all duration-500"
        style={{
          width: `${
            productiveMinutes > 0
              ? (productiveMinutes / (18 * 60)) * 100
              : 0
          }%`,
        }}
      />
    </div>
  </div>

</div>
          
  <p className="text-sm text-purple-400 mt-2">
  ‚öîÔ∏è Rival: Level {rivalLevel} | XP {rivalXP}/{getXPForLevel(rivalLevel)}
</p>
  <p
    className={`mt-1 text-sm font-bold ${
      rivalLevel > level || (rivalLevel === level && rivalXP > xp)
        ? "text-red-500"
        : "text-green-400"
    } transition-colors duration-500`}
  >
    {rivalLevel > level || (rivalLevel === level && rivalXP > xp)
      ? "üî• Rival is ahead of you!"
      : "‚úÖ You are ahead of your rival"}
  </p>       
<div class="relative flex items-center justify-center w-[300px] h-[300px]">

<div className="flex items-center justify-center w-28 h-28 rounded-full 
              border-4 border-purple-500 shadow-[0_0_20px_rgba(168,85,247,0.8)] animate-pulse">
  <img
    src={characterImages[Math.min(level - 1, 10)]}
    alt={`Jinwoo Evolution Level ${level}`}
    className="w-24 h-24 rounded-full object-cover aura"
    style={{ "--aura-color": getAuraColor(level) }}
  />
</div>

  
  <img src="images/dagger1.png"
       class="absolute w-8 h-8 animate-[fly1_4s_linear_infinite]" />
  <img src="images/dagger2.png"
       class="absolute w-8 h-8 animate-[fly2_5s_linear_infinite]" />
  <img src="images/dagger3.png"
       class="absolute w-8 h-8 animate-[fly3_6s_linear_infinite]" />

</div>
  


{/* Rank Badge */}
{(() => {
  const rank = getRankInfo(level);
  return (
    <img
      src={rank.url}
      alt="Rank Badge"
      className="badge mx-auto mt-3 w-12 h-12"
      style={{ "--badge-color": rank.color }}
    />
  );
})()}

    <p className="mt-1 text-lg font-semibold text-gray-300">
    Level {level} ({getRank(level)})
  </p>
 <div className="w-full bg-gray-700 rounded-full h-4 mt-4 overflow-hidden shadow-inner">  
    <div  
      className="bg-gradient-to-r from-blue-500 to-purple-600 h-4 rounded-full transition-all duration-1000 ease-in-out"  
      style={{ width: `${(xp / getXPForLevel(level)) * 100}%` }}  
    ></div>  
  </div>    

  <p className="text-sm mt-2 text-gray-300 font-medium">
    {xp} / {getXPForLevel(level)} XP
  </p>

<button
  onClick={handleRelapse}
  className="bg-gradient-to-r from-red-500 via-pink-500 to-yellow-500 
             hover:from-red-600 hover:via-pink-600 hover:to-yellow-600
             transition-all duration-300 mt-5 px-5 py-2 
             rounded-full w-full font-semibold shadow-lg 
             text-white tracking-wide animate-pulse"
>
  Lost Focus (-50 XP)
</button>

<button
  onClick={triggerUrgeRedirect}
  className="bg-blue-600 hover:bg-blue-700 transition-colors duration-200 mt-3 px-5 py-2 rounded-full w-full font-semibold shadow-md"
>
  Stay Strong
</button>
</div>


{/* Urge Modal */}
{showUrgeModal && (
  <div
    className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4
      animate-fadeIn"
  >
    <div
      className="bg-gray-800 p-6 rounded-2xl text-center max-w-sm shadow-lg border border-red-600
        transform animate-scaleIn"
    >
      <h2 className="text-2xl font-bold mb-4 text-red-400 tracking-wide">
        Redirect Your Urge
      </h2>
      <p className="mb-5 text-gray-300">{urgeTask}</p>
      <p className="text-red-400 mb-6 font-semibold animate-pulse">
        Wait for 10 seconds...
      </p>

      <div className="flex gap-4 justify-center">
        <button
          onClick={handleUrgeComplete}
          className="bg-green-600 hover:bg-green-700 transition-colors duration-200 px-5 py-2 rounded-lg font-semibold text-white shadow-md"
        >
          Done (+3 XP)
        </button>
        <button
          onClick={handleUrgeSkip}
          className="bg-red-600 hover:bg-red-700 transition-colors duration-200 px-5 py-2 rounded-lg font-semibold text-white shadow-md"
        >
          Skip (-5 XP)
        </button>
      </div>
    </div>

    <style>{`
      @keyframes fadeIn {
        from {opacity: 0;}
        to {opacity: 1;}
      }
      @keyframes scaleIn {
        from {transform: scale(0.85); opacity: 0;}
        to {transform: scale(1); opacity: 1;}
      }
      .animate-fadeIn {
        animation: fadeIn 0.3s ease forwards;
      }
      .animate-scaleIn {
        animation: scaleIn 0.3s ease forwards;
      }
      .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      @keyframes pulse {
        0%, 100% {opacity: 1;}
        50% {opacity: 0.5;}
      }
    `}</style>
  </div>
)}
      </header>
        {showMotivation && (
  <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-xl text-center shadow-lg max-w-sm">
      <h2 className="text-lg font-bold mb-4 text-green-400">üî• Motivation</h2>
      <p className="mb-6">{motivationText}</p>
      <button
        onClick={() => setShowMotivation(false)}
        className="bg-blue-600 px-5 py-2 rounded-lg shadow-md"
      >
        OK
      </button>
    </div>
  </div>
)}

      

  {showReward && (
  <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-2xl text-center shadow-2xl border border-yellow-500 max-w-sm">
      <h2 className="text-2xl font-bold mb-4 text-yellow-400">üèÜ Reward Unlocked</h2>
      <p className="mb-4 text-lg text-white">{rewardText}</p>

      {!rewardActive ? (
        <button
          onClick={() => {
            setRewardTime(600); // 600 sec = 10 min
            setRewardActive(true);
          }}
          className="bg-yellow-500 hover:bg-yellow-600 text-black px-6 py-2 rounded-lg font-bold shadow-md"
        >
          Start 10 min Reward
        </button>
      ) : (
        <p className="text-lg font-bold text-green-400 animate-pulse">
          ‚è≥ {Math.floor(rewardTime / 60)}:{String(rewardTime % 60).padStart(2, "0")}
        </p>
      )}

      <button
        onClick={() => {
          setShowReward(false);
          setRewardActive(false);
        }}
        className="mt-4 bg-red-600 hover:bg-red-700 px-6 py-2 rounded-lg shadow-md font-semibold"
      >
        End Reward Early
      </button>
    </div>
  </div>
)}

{/* ===== EMERGENCY BUTTON ===== */}
<div className="mt-6 flex flex-col items-center">
  <button
    onClick={triggerEmergencyDay}
    disabled={emergencyUsed}
    className={`px-6 py-3 font-bold rounded-xl shadow-lg transition ${
      emergencyUsed
        ? "bg-gray-700 text-gray-300 cursor-not-allowed"
        : "bg-red-600 hover:bg-red-700 text-white animate-pulse"
    }`}
  >
    üö® {emergencyUsed ? "Emergency Used Today" : "Emergency Button"}
  </button>

  {/* optional monthly log info */}
  <p className="text-sm text-gray-400 mt-2">
    Used this month: {
      JSON.parse(localStorage.getItem("emergencyLog") || "[]")
        .filter(e => new Date(e.date).getMonth() === new Date().getMonth()).length
    } / 2
  </p>
</div>
      {showEmergencyModal && (
  <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center">
    <div className="bg-gray-900 text-white rounded-2xl p-6 w-96 text-center border border-red-500/50 shadow-2xl">
      <h2 className="text-2xl font-bold mb-3">üö® Declare Emergency Day?</h2>
      <p className="text-sm text-gray-300 mb-4">
        This will <b>nullify all today's</b> tasks, contracts, mocks, punishments, focus sessions, and debts.
        <br /><br />
        You will get <b>+38 XP</b> but no rewards or punishments today.
        <br /><br />
        <span className="text-red-400">Use only for genuine emergencies.</span>
      </p>
      <div className="flex justify-center gap-3 mt-4">
        <button
          onClick={() => setShowEmergencyModal(false)}
          className="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600"
        >
          Cancel
        </button>
        <button
          onClick={confirmEmergencyDay}
          className="px-4 py-2 bg-red-600 rounded-lg hover:bg-red-700"
        >
          Confirm
        </button>
      </div>
    </div>
  </div>
)}
{/* üî• INDEPENDENT CONTRACT POPUP */}
{showContractModal && (
  <div className="fixed inset-0 z-50 bg-black bg-opacity-60 flex items-center justify-center backdrop-blur-sm">
    <div className="bg-gray-900 text-white p-6 rounded-2xl w-80 border border-red-500 shadow-2xl">
      <h2 className="text-lg font-bold text-center mb-3 text-red-400">
        Contract Alert
      </h2>

      <p className="text-sm text-gray-200 text-center whitespace-pre-line">
        {contractModalMessage}
      </p>

      <div className="flex justify-center mt-5">
        <button
          onClick={() => setShowContractModal(false)}
          className="px-6 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition font-semibold"
        >
          OK
        </button>
      </div>
    </div>
  </div>
)}
      
      {/* NEW CONTRACT MODAL (locks other UI when shown) */}
{showNewContract && (
  <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4">
    <div className="bg-gray-800 p-6 rounded-xl shadow-lg w-full max-w-sm text-center text-white relative">
      <h3 className="text-xl font-bold mb-4">‚úçÔ∏è Forge New Shadow Contract</h3>
      <input
        type="text"
        placeholder="Goal (e.g. 300 English words)"
        className="w-full p-2 rounded mb-3 text-black"
        value={contractGoalInput}
        onChange={e => setContractGoalInput(e.target.value)}
      />
      <input
        type="number"
        placeholder="Days to complete"
        className="w-full p-2 rounded mb-3 text-black"
        value={contractDaysInput}
        onChange={e => setContractDaysInput(e.target.value)}
      />
      <div className="flex gap-2 justify-center">
        <button
          onClick={createContractFromInputs}
          className="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded-lg"
        >Forge</button>
        <button
          onClick={() => {
            // If user tries to cancel but UI is locked, prevent cancel
            if (uiLockedByContract || !hasActiveContract()) {
              alert("‚ö†Ô∏è You must create a contract now ‚Äî no rest allowed.");
              return;
            }
            setShowNewContract(false);
          }}
          className="bg-gray-600 px-4 py-2 rounded-lg"
        >Cancel</button>
      </div>
    </div>
  </div>
)}
{contracts.map(c => (
  <>
    <div key={`${c.id}-summary`} className="bg-gray-800 p-3 rounded-lg mb-2 flex justify-between items-center">
      <div>
        <p className="text-yellow-300">{c.goal}</p>
        <p className="text-xs">
          {c.done ? "‚úÖ Completed" : c.failed ? "üíÄ Failed" : "üïì Active"} | 
          Days: {c.progress.filter(Boolean).length}/{c.days}
        </p>
      </div>

      {/* üóëÔ∏è Delete Button */}
      <button
        onClick={() => deleteContract(c.id)}
        className="text-red-400 hover:text-red-600 ml-3 text-sm font-bold"
      >
        ‚úñ
      </button>
    </div>

    <div key={`${c.id}-details`} className="bg-gray-800 p-3 rounded-lg mb-3">
      <div className="flex justify-between items-center">
        <div>
          <p className="text-yellow-400 font-semibold">{c.goal}</p>
          <p className="text-xs">Ends: {new Date(c.end).toLocaleString()}</p>
          <p className="text-xs">Progress: {c.progress.filter(Boolean).length}/{c.days}</p>
        </div>
        <div className="text-right">
          {!c.done && !c.failed && (
            <>
              <button onClick={() => markContractProgress(c.id)} className="bg-green-600 px-2 py-1 rounded text-xs mr-1">Mark Today</button>
              <button onClick={() => completeContract(c.id)} className="bg-blue-600 px-2 py-1 rounded text-xs mr-1">Force Complete</button>
              <button onClick={() => failContract(c.id)} className="bg-red-600 px-2 py-1 rounded text-xs">Force Fail</button>
            </>
          )}
          {c.done && <span className="text-green-400">‚úÖ Completed</span>}
          {c.failed && <span className="text-red-400">üíÄ Failed</span>}
        </div>
      </div>

      {/* Visual daily progress dots */}
      <div className="flex gap-1 overflow-auto mt-3">
        {c.progress.map((p, i) => (
          <div key={i} className={`h-3 w-3 rounded-full ${p ? 'bg-green-400' : 'bg-red-500'}`} title={`Day ${i + 1}`} />
        ))}
      </div>
    </div>
  </>
))}

   {showProofModal && proofTask && (
  <div className="fixed inset-0 z-50 flex items-center justify-center">
    <div className="absolute inset-0 bg-black/70"></div>

    <div className="relative bg-gray-900 text-white rounded-2xl p-6 w-96 max-w-[92%] shadow-2xl border border-purple-600/40 animate-fadeIn">
      <h3 className="text-lg font-bold mb-2">üßæ Proof: "{proofTask.title}"</h3>

      <p className="text-sm mb-2 text-gray-300">
        This task ended at{" "}
        {(() => {
          // display best effort end time
          if (proofTask.type === 'daily' && proofTask.end) return proofTask.end;
          if (proofTask.type === 'timed' && proofTask.created) {
            const created = new Date(proofTask.created);
            const deadline = new Date(created);
            deadline.setDate(created.getDate() + parseInt(proofTask.days || 0));
            return deadline.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
          return "";
        })()}
        . Provide a short proof (text or photo).
      </p>

      <textarea
        value={proofText}
        onChange={e => setProofText(e.target.value)}
        placeholder="E.g., Revised 50 vocab words, wrote meanings & examples..."
        className="w-full h-28 p-2 rounded-md text-black mb-3"
      />

      <div className="mb-3">
        <input
          type="file"
          accept="image/*"
          onChange={(e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onloadend = () => setProofImage(reader.result);
            reader.readAsDataURL(file);
          }}
        />
        {proofImage && (
          <img src={proofImage} alt="proof" className="mt-2 w-28 h-20 object-cover rounded-md" />
        )}
      </div>

      <div className="flex justify-end gap-3">
        <button
          onClick={skipProofAndPunish}
          className="px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-700"
        >
          Skip
        </button>
        <button
          onClick={submitProof}
          className="px-4 py-2 bg-emerald-500 rounded-lg hover:bg-emerald-600"
        >
          Submit Proof
        </button>
      </div>
    </div>
  </div>
)}   

  {/* ===== Focus Controls ===== */}
<div className="bg-gray-800 p-4 rounded-2xl mt-4 shadow-lg text-center">
  {!focusActive && !onBreak ? (
    <>
      <h2 className="text-lg font-bold mb-2">üéØ Focus Mode</h2>
      <p className="text-sm text-gray-300 mb-3">Choose session length:</p>
      <div className="flex justify-center gap-3">
        {[25, 45, 60].map(min => (
          <button
            key={min}
            onClick={() => startFocusSession(min)}
            className="px-4 py-2 bg-indigo-600 rounded-xl hover:bg-indigo-700"
          >
            {min} min
          </button>
        ))}
      </div>
    </>
  ) : (
    <div>
      <h2 className="text-lg font-bold mb-2">{focusActive ? "üïí Focus Active" : "‚òï On Break"}</h2>
      <p className="text-sm text-gray-200 mb-3">
        {focusActive ? `${focusDuration} minute session` : `Break time`}
      </p>
      <p className="text-2xl font-mono mb-3">
        {focusActive
          ? `${Math.floor(focusRemaining/60).toString().padStart(2,'0')}:${String(focusRemaining%60).padStart(2,'0')}`
          : `${Math.floor(breakRemaining/60).toString().padStart(2,'0')}:${String(breakRemaining%60).padStart(2,'0')}`
        }
      </p>
      {focusActive ? (
        <button onClick={() => endFocusSession(false)} className="px-4 py-2 bg-red-600 rounded-xl">Abort Focus</button>
      ) : (
        <button onClick={finishBreak} className="px-4 py-2 bg-emerald-600 rounded-xl">Skip Break</button>
      )}
    </div>
  )}
</div>

{/* ===== Immersive Overlays ===== */}
{focusActive && (
  <div className="fixed inset-0 bg-gradient-to-b from-gray-950 via-gray-900 to-gray-950 text-white z-50 flex flex-col items-center justify-center">
    <h1 className="text-3xl font-bold mb-4 tracking-wide animate-pulse">üéØ Deep Focus Mode</h1>
    <p className="text-lg text-gray-300 mb-2">{focusDuration}-minute session</p>
    <p className="text-6xl font-mono my-6">
      {Math.floor(focusRemaining/60).toString().padStart(2,'0')}:
      {String(focusRemaining%60).padStart(2,'0')}
    </p>
    <button onClick={() => endFocusSession(false)} className="px-6 py-3 bg-red-700 rounded-xl">Abort Focus</button>
  </div>
)}

{onBreak && (
  <div className="fixed inset-0 bg-gradient-to-b from-emerald-900 via-emerald-800 to-emerald-900 text-white z-50 flex flex-col items-center justify-center">
    <h1 className="text-3xl font-bold mb-4">‚òï Break Time</h1>
    <p className="text-5xl font-mono mb-6">
      {Math.floor(breakRemaining/60).toString().padStart(2,'0')}:
      {String(breakRemaining%60).padStart(2,'0')}
    </p>
    <button onClick={finishBreak} className="px-4 py-2 bg-emerald-600 rounded-xl">End Break</button>
  </div>
)}

{/* ===== Focus Stats ===== */}
<div className="bg-gray-800 mt-6 p-4 rounded-2xl shadow-md text-gray-200">
  <div className="flex justify-between items-center mb-2">
    <h3 className="text-lg font-bold">üß≠ Focus Stats</h3>
    <div className="text-sm text-gray-400">Total Sessions: {focusStats.length}</div>
  </div>

  {focusStats.length === 0 ? (
    <p className="text-sm text-gray-400">No sessions yet. Start a Focus session.</p>
  ) : (
    <ul className="text-sm space-y-1 max-h-36 overflow-y-auto">
      {focusStats.slice().reverse().map((s,i) => (
        <li key={i} className="flex justify-between border-b border-gray-700 py-1">
          <span>{s.date}</span>
          <span className="text-emerald-400">{s.minutes} min</span>
        </li>
      ))}
    </ul>
  )}

  <div className="mt-3 text-sm text-gray-400">
    Total minutes: {focusStats.reduce((a,b)=>a+(b.minutes||0),0)}
  </div>
</div>

{/* ==========================================================
     üîÆ JOURNAL OF RESOLVE - UI SECTION
========================================================== */}

{/* ‚ú® Floating Summon Journal Button */}
<button
  onClick={() => setShowJournalModal(true)}
  className="fixed bottom-6 right-6 bg-indigo-700 hover:bg-indigo-800 
             text-white px-5 py-3 rounded-full shadow-lg ring-2 ring-purple-500 animate-pulse z-50">
  ‚ú® Summon Journal
</button>

{/* üíé Crystals List */}
<div className="grid grid-cols-2 sm:grid-cols-3 gap-3 mt-6">
  {crystals.length === 0 && (
    <div className="col-span-full text-gray-400 text-center">
      No crystals yet. Summon the Journal to forge one.
    </div>
  )}

  {crystals.map(c => (
    <div
      key={c.id}
      className="bg-indigo-700 p-3 rounded-xl shadow-md hover:shadow-indigo-400/40 transition-all"
    >
      <div className="text-xs text-yellow-300">{c.date}</div>
      {c.situation && (
        <div className="text-gray-300 text-xs">üí≠ {c.situation}</div>
      )}
      <div className="mt-1 font-semibold text-white truncate">‚öôÔ∏è {c.lesson}</div>
      <div className="text-sm italic text-gray-300 line-clamp-2">
        üîÆ {c.resolve}
      </div>

      <div className="flex flex-wrap gap-2 mt-2">
        <button
          onClick={() => viewJournalEntry(c)}
          className="flex-1 bg-indigo-500 text-white px-2 py-1 rounded-md hover:bg-indigo-400 text-sm"
        >
          üëÅ View
        </button>
        <button
          onClick={() => editJournalEntry(c)}
          className="flex-1 bg-gray-700 text-gray-200 px-2 py-1 rounded-md hover:bg-gray-600 text-sm"
        >
          ‚úèÔ∏è Edit
        </button>
        <button
          onClick={() => absorbCrystal(c.id)}
          className="flex-1 bg-yellow-400 text-black font-semibold px-2 py-1 rounded-md hover:bg-yellow-300 text-sm"
        >
          üíé Absorb
        </button>
      </div>
    </div>
  ))}
</div>

{/* üìú Add/Edit Modal */}
{showJournalModal && (
  <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-2xl w-11/12 max-w-md border border-indigo-600 shadow-lg">
      <h2 className="text-xl text-indigo-400 font-bold mb-3 text-center">
        üìú Journal of Resolve
      </h2>

      <input
        value={situation}
        onChange={e => setSituation(e.target.value)}
        placeholder="üí≠ Situation (optional)"
        className="w-full p-2 mb-2 rounded-md bg-gray-800 border border-gray-700 text-sm focus:ring-2 focus:ring-indigo-500"
      />
      <textarea
        value={lesson}
        onChange={e => setLesson(e.target.value)}
        placeholder="‚öôÔ∏è Lesson Learned"
        className="w-full p-2 mb-2 rounded-md bg-gray-800 border border-gray-700 text-sm h-16 focus:ring-2 focus:ring-indigo-500"
      />
      <textarea
        value={resolveText}
        onChange={e => setResolveText(e.target.value)}
        placeholder="üîÆ How I'll act next time"
        className="w-full p-2 mb-3 rounded-md bg-gray-800 border border-gray-700 text-sm h-16 focus:ring-2 focus:ring-indigo-500"
      />

      <div className="flex gap-2">
        <button
          onClick={saveJournalEntry}
          className="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white py-2 rounded-md font-semibold"
        >
          {editEntryId ? "Update Entry" : "Forge Crystal"}
        </button>
        <button
          onClick={() => setShowJournalModal(false)}
          className="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-200 py-2 rounded-md font-semibold"
        >
          Cancel
        </button>
      </div>
    </div>
  </div>
)}

{/* üëÅ View Modal */}
{viewEntryModal && (
  <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-2xl w-11/12 max-w-md border border-indigo-600 shadow-lg">
      <h2 className="text-xl text-yellow-400 font-bold mb-3 text-center">
        üíé Resolved Entry
      </h2>
      <div className="text-sm text-gray-400 mb-2">{viewEntryModal.date}</div>
      {viewEntryModal.situation && (
        <div className="mb-2 text-gray-300">
          üí≠ <b>Situation:</b> {viewEntryModal.situation}
        </div>
      )}
      <div className="mb-2 text-indigo-300">
        ‚öôÔ∏è <b>Lesson:</b> {viewEntryModal.lesson}
      </div>
      <div className="text-green-300">
        üîÆ <b>Resolve:</b> {viewEntryModal.resolve}
      </div>
      <div className="text-right mt-4">
        <button
          onClick={() => setViewEntryModal(null)}
          className="bg-yellow-500 text-black px-4 py-1 rounded-md hover:bg-yellow-400"
        >
          Close
        </button>
      </div>
    </div>
  </div>
)}

{/* ‚ö° Toast */}
{journalToast && (
  <div className="fixed bottom-6 right-6 bg-yellow-500 text-black px-4 py-2 rounded-xl shadow-lg z-50">
    {journalToast}
  </div>
)}

 <div className="mt-6 grid grid-cols-2 gap-3">
  <button onClick={() => startAppUsage("YouTube", "https://www.youtube.com")} className="bg-red-600 ...">üé¨ YouTube</button>
  <button onClick={() => startAppUsage("WhatsApp", "https://web.whatsapp.com")} className="bg-green-600 ...">üí¨ WhatsApp</button>
  <button onClick={() => startAppUsage("Telegram", "https://web.telegram.org")} className="bg-blue-600 ...">üì© Telegram</button>
  <button onClick={() => startAppUsage("Instagram", "https://www.instagram.com")} className="bg-pink-600 ...">üì∏ Instagram</button>
</div>   
      {activeApp && (
  <div className="mt-3 flex items-center gap-3">
    <div className="px-3 py-2 bg-gray-800 rounded-lg text-sm text-gray-200">
      Active: <span className="font-semibold ml-2">{activeApp}</span>
    </div>
    <button onClick={stopAppUsage} className="px-3 py-2 bg-yellow-600 rounded-lg text-white">Stop timer</button>
  </div>
)}
      {showAppUsageModal && (
  <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60">
    <div className="bg-gray-900 text-white p-5 rounded-2xl w-80 border border-purple-500 shadow-lg">
      <h3 className="text-lg font-semibold mb-2 text-center">{activeApp} session</h3>
      <p className="text-sm text-gray-300 mb-3 text-center">Duration: <span className="font-medium">{appElapsed} min</span></p>
      <p className="text-sm text-gray-400 mb-4 text-center">Was this productive or wastage?</p>
      <div className="flex gap-3 justify-center">
        <button onClick={() => handleAppUsageResult("productive")} className="px-4 py-2 bg-green-600 rounded-lg">Productive</button>
        <button onClick={() => handleAppUsageResult("waste")} className="px-4 py-2 bg-red-600 rounded-lg">Wastage</button>
      </div>
    </div>
  </div>
)}

      {/* Dopamine Detox Section */}
      <div  className="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg max-w-md mx-auto">
  <h2 className="text-xl font-semibold mb-4 text-green-400 tracking-wide">
    Dopamine Detox
  </h2>

  <div className="flex justify-between items-center mb-4">
    <span className="text-gray-300 font-medium">Detox Mode</span>
    <label className="switch relative inline-block w-14 h-8">
      <input
        type="checkbox"
        checked={dopamineActive}
        onChange={() => setDopamineActive(!dopamineActive)}
        className="opacity-0 w-0 h-0"
      />
      <span className="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 bg-gray-600 rounded-full transition-colors duration-300 ease-in-out"></span>
      <span className="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full shadow-md transition-transform duration-300 ease-in-out"></span>
    </label>
  </div>

  <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
    <div
      className="bg-green-500 h-4 rounded-full transition-all duration-1000 ease-in-out"
      style={{ width: `${dopamineLevel}%` }}
    ></div>
  </div>

  <p className="text-sm mt-2 text-gray-300 font-medium">
    Dopamine Level: <span className="font-bold">{dopamineLevel.toFixed(1)}%</span>
  </p>
  <p className="text-sm text-gray-300 font-medium">
    Time Remaining: <span className="font-bold">{timeRemaining}</span>
  </p>

  <style>{`
    .switch input:checked + .slider {
      background-color: #22c55e;
    }
    .switch input:checked + .slider + .dot {
      transform: translateX(26px);
    }
  `}</style>
</div>
<div className="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg">
  <h2 className="text-xl font-semibold mb-4">üåÖ Wake Up Log</h2>

  <div className="flex items-center gap-2 mb-3">
    <span className="text-gray-300">Goal:</span>
    <input
      type="time"
      value={goalWakeUp}
      onChange={(e) => {
        setGoalWakeUp(e.target.value);
        localStorage.setItem("goalWakeUp", e.target.value);
      }}
      className="p-2 rounded text-black"
    />
  </div>

  {wakeUpLoggedToday ? (
    <p className="text-green-400">Logged: {wakeUpTime}</p>
  ) : (
    <button
      onClick={logWakeUp}
      className="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded shadow-md"
    >
      Log Wake Up
    </button>
  )}
</div>
      <br/>
{/* Trigger Button */}
      {/* ---- Trigger Button ---- */}
{!challenge && (
  <button
    onClick={() => setShowDisrespectModal(true)}
    className="relative w-full px-6 py-3 font-extrabold text-lg text-white 
               rounded-xl shadow-lg overflow-hidden
               bg-gradient-to-r from-red-800 via-red-600 to-orange-500
               hover:from-red-900 hover:via-red-700 hover:to-orange-600
               transition-all duration-300 ease-in-out
               animate-pulse flex items-center justify-center gap-2"
  >
    <span className="text-2xl">üíÄ</span>
    <span className="animate-bounce">‚ö°</span>
    <span>DISRESPECT TRIGGER</span>
    <span className="animate-bounce">‚ö°</span>
    <span className="text-2xl">üî•</span>
  </button>
)}
      

{/* ---- Modal ---- */}
{showDisrespectModal && (
  <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-60">
    <div className="bg-gray-900 p-6 rounded-2xl w-96 text-white">
      <h2 className="text-xl font-bold mb-4">üî• Set Disrespect Challenge</h2>

      <label className="block mb-2">Select Challenge Type:</label>
      <select
        value={challengeType}
        onChange={(e) => setChallengeType(e.target.value)}
        className="p-2 rounded w-full text-black mb-3"
      >
        <option value="">-- Choose Type --</option>
        <option value="streak">Days Streak</option>
        <option value="percentile">Mock Percentile</option>
        <option value="tasks">Tasks Count</option>
      </select>

      <label className="block mb-2">Enter Target:</label>
      <input
        type="number"
        placeholder="Target value"
        value={challengeTarget}
        onChange={(e) => setChallengeTarget(Number(e.target.value))}
        className="p-2 rounded w-full text-black mb-3"
      />

      {challengeType === "tasks" && (
        <>
          <label className="block mb-2">Duration (days):</label>
          <input
            type="number"
            placeholder="e.g. 7"
            value={challengeDuration}
            onChange={(e) => setChallengeDuration(Number(e.target.value))}
            className="p-2 rounded w-full text-black mb-3"
          />
        </>
      )}

      <div className="flex justify-between mt-4">
        <button
          onClick={() => setShowDisrespectModal(false)}
          className="bg-gray-600 px-4 py-2 rounded"
        >
          Cancel
        </button>
        <button
          onClick={() => {
            startChallenge(challengeType, challengeTarget, challengeDuration);
            setShowDisrespectModal(false);
          }}
          className="bg-green-600 px-4 py-2 rounded"
        >
          Start
        </button>
      </div>
    </div>
  </div>
)}

{/* ---- Active Challenge ---- */}
{challenge && (
  <div className="bg-gray-800 p-4 mt-4 rounded-xl text-white">
    <h2 className="text-lg font-bold mb-2">üî• Active Challenge</h2>

    {/* Streak */}
    {challenge.type === "streak" && (
      <div>
        <p>{challenge.target}-Day Study Streak</p>
        {challenge.days.map((done, i) => (
          <button
            key={i}
            onClick={() => markStreakDayComplete(i)}
            disabled={done}
            className={`mt-2 w-full p-2 rounded ${
              done ? "bg-green-600" : "bg-red-600"
            }`}
          >
            Day {i + 1}: {done ? "‚úÖ Complete" : "‚ùå Pending"}
          </button>
        ))}
      </div>
    )}

    {/* Percentile */}
    {challenge.type === "percentile" && (
      <div>
        <p>{challenge.target} Mocks ‚â• 90%</p>
        {challenge.logs.map((log, i) => (
          <input
            key={i}
            type="number"
            placeholder={`Mock ${i + 1} Score`}
            value={log.score ?? ""}
            className="w-full mt-2 p-2 text-black rounded"
            onChange={(e) => saveMockPercentile(i, Number(e.target.value))}
          />
        ))}
      </div>
    )}

    {/* Tasks */}
    {challenge.type === "tasks" && (
      <div>
        <p>
          {challenge.target} Tasks in {challenge.duration} Days
        </p>
        <p className="mt-2">
          Progress: {challenge.progress}/{challenge.target}
        </p>
        <button
          onClick={addOneTask}
          className="bg-blue-600 mt-2 px-4 py-2 rounded w-full"
        >
          +1 Task
        </button>
      </div>
    )}

    {/* Status Badge */}
    {status === "completed" && (
      <div className="bg-green-700 text-white px-3 py-1 rounded mt-3 text-center font-bold">
        üèÜ Challenge Completed
      </div>
    )}

    {status === "failed" && (
      <div className="bg-red-700 text-white px-3 py-1 rounded mt-3 text-center font-bold">
        üíÄ Challenge Failed
      </div>
    )}

    {/* Reset */}
    {status && (
      <button
        onClick={() => {
          setChallenge(null);
          setStatus("");
        }}
        className="bg-gray-600 mt-3 px-4 py-2 rounded w-full"
      >
        Reset Challenge
      </button>
    )}
  </div>
)}

  
     {/* === Mock Test Tracker === */}
<div className="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg max-w-md mx-auto">
  <h2 className="text-xl font-semibold mb-4 text-yellow-400">üìä Mock Test Tracker</h2>

  <p className="text-sm text-gray-300 mb-2">
    Best Percentile: <span className="font-bold text-green-400">{bestPercentile}%</span>
  </p>

  {Date.now() < graceDeadline ? (
    // üö´ Grace Period Message
    <div className="bg-red-900 text-red-300 p-3 rounded-md text-center">
      üö´ No mock allowed today! <br />
      Revise wrong questions only. <br />
      Grace Period Active until{" "}
      {new Date(graceDeadline).toLocaleDateString()}.
    </div>
  ) : (
    // ‚úÖ Log Mock Percentile
    <div className="flex gap-2">
      <input
        type="number"
        min="0"
        max="100"
        placeholder="Enter Percentile"
        className="p-2 rounded w-full text-black"
        onChange={(e) => setTempPercentile(e.target.value)}
      />
      <button
        onClick={() => {
          if (!tempPercentile) {
            alert("‚ö†Ô∏è Please enter a percentile!");
            return;
          }
          logMockPercentile(tempPercentile);
          setTempPercentile("");
        }}
        className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded shadow-md text-white"
      >
        Log
      </button>
    </div>
  )}

  {/* Show Last 5 Logs */}
  <div className="mt-4">
    <h3 className="text-sm font-semibold text-gray-300 mb-2">Recent Logs</h3>
    {mockHistory.length === 0 ? (
      <p className="text-gray-500 text-sm">No logs yet.</p>
    ) : (
      <ul className="space-y-1 text-sm">
        {mockHistory.slice(-5).map((entry, i) => (
          <li
            key={i}
            className={`p-2 rounded ${
              entry.percentile >= bestPercentile
                ? "bg-green-700 text-white"
                : "bg-gray-700 text-gray-200"
            }`}
          >
            {entry.date}: {entry.percentile}%
          </li>
        ))}
      </ul>
    )}
  </div>
</div> 
<button 
  onClick={() => openBadHabitSelector()}
  className="fixed bottom-5 right-5 bg-red-600 px-4 py-2 rounded-lg"
>
  ‚ö† Bad Habit
</button>

<div className="mt-5 max-w-sm mx-auto bg-gray-900 p-5 rounded-xl shadow-lg text-center text-white">
  <h2 className="text-lg font-semibold mb-4">Fog Meter</h2>

  <div className="relative w-36 h-36 mx-auto mb-4">
    <svg className="transform -rotate-90" width={144} height={144} viewBox="0 0 144 144">
      <circle
        cx="72"
        cy="72"
        r="64"
        stroke="#374151"  /* gray-700 */
        strokeWidth="16"
        fill="none"
      />
      <circle
        cx="72"
        cy="72"
        r="64"
        stroke={fogLevel < 40 ? "#22c55e" : fogLevel < 70 ? "#eab308" : "#ef4444"} /* green/yellow/red */
        strokeWidth="16"
        fill="none"
        strokeDasharray={2 * Math.PI * 64}
        strokeDashoffset={(1 - fogLevel / 100) * 2 * Math.PI * 64}
        strokeLinecap="round"
        style={{ transition: "stroke-dashoffset 1s ease, stroke 0.5s ease" }}
      />
    </svg>

    <div className="absolute inset-0 flex flex-col items-center justify-center">
      <p
        className="text-4xl font-bold"
        style={{ color: fogLevel < 40 ? "#22c55e" : fogLevel < 70 ? "#eab308" : "#ef4444" }}
      >
        {fogLevel.toFixed(0)}%
      </p>
      <p className="text-sm mt-1 text-gray-400">Fog Level</p>
    </div>
  </div>

  {/* Dropdown and Confirm button */}
  <div className="text-left">
    <p className="text-sm font-semibold mb-1">Adjust Fog Level</p>
    <select
      onChange={(e) => setFogReason(e.target.value)}
      className="w-full rounded-md p-2 text-black focus:outline-none focus:ring-2 focus:ring-blue-400 transition"
      value={fogReason}
    >
      <option value="">-- Select a reason --</option>
      <optgroup label="Increase Fog">
        {fogIncreaseOptions.map((item, index) => (
          <option key={`inc-${index}`} value={`inc-${item}`}>
            {item}
          </option>
        ))}
      </optgroup>
      <optgroup label="Reduce Fog">
        {fogReduceOptions.map((item, index) => (
          <option key={`dec-${index}`} value={`dec-${item}`}>
            {item}
          </option>
        ))}
      </optgroup>
    </select>

    {fogReason && (
      <button
        onClick={() => {
          if (fogReason.startsWith("inc-")) {
            setFogLevel(Math.min(100, fogLevel + 5));
          } else {
            setFogLevel(Math.max(0, fogLevel - 5));
          }
          setFogReason("");
        }}
        className="mt-3 w-full bg-blue-600 hover:bg-blue-700 transition-colors duration-300 text-white font-semibold py-2 rounded-md shadow-md"
      >
        Confirm
      </button>
    )}
  </div>
</div>

      {punishments.length > 0 && (
  <div
    className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4
      transition-opacity duration-300 ease-in-out opacity-100"
    style={{ animation: 'fadeIn 0.3s ease forwards' }}
  >
    <div
      className="bg-gray-800 p-6 rounded-2xl w-full max-w-sm text-center
        transform scale-100 transition-transform duration-300 ease-in-out shadow-lg border border-red-600"
      style={{ animation: 'scaleIn 0.3s ease forwards' }}
    >
      <h2 className="text-xl font-bold mb-3 text-red-400 tracking-wide">Punishment</h2>
      <pre className="mb-3 whitespace-pre-wrap text-left bg-gray-900 p-4 rounded-lg shadow-inner text-gray-300">
        {punishments[0].text}
      </pre>

      {['boss', 'smallBoss'].includes(punishments[0].type) && taskLog.length > 0 && (
  <div className="text-left mb-3 max-h-36 overflow-y-auto">
    <h3 className="font-semibold mb-1 text-red-400">Last 7 Tasks:</h3>
    <ul className="list-disc list-inside text-sm text-gray-300">
      {taskLog.slice(-7).map((t, i) => (
        <li key={i}>{t}</li>
      ))}
    </ul>
  </div>
)}

{['boss', 'smallBoss', 'weeklyBoss', 'dungeon'].includes(punishments[0].type) && (
  <div className="flex flex-col items-center mb-4">
    <img
      src="https://i.ibb.co/rG54PGTL/image-from-rawpixel-id-12652540-png.png"
      alt="Dragon Logo"
      className={`dragon-logo ${
        punishments[0].type === 'boss' || punishments[0].type === 'smallBoss'
          ? 'glow-red'
          : punishments[0].type === 'weeklyBoss'
          ? 'glow-gold'
          : 'glow-purple'
      }`}
    />
    <p className="mt-2 text-red-400 text-lg font-bold">
      Time Left: {formatTime(timer)}
    </p>
  </div>
)}

      <div className="flex flex-col gap-3 mt-5">
        <button
  onClick={() => handlePunishmentAction(0, "complete")}
  className="bg-green-600 hover:bg-green-700 transition-colors duration-200 py-3 rounded-lg font-semibold shadow-md text-white"
>
  Complete
</button>

<button
  onClick={() => handlePunishmentAction(0, "forgive")}
  className="bg-yellow-500 hover:bg-yellow-600 transition-colors duration-200 py-3 rounded-lg font-semibold shadow-md text-white"
>
  Forgive (-{punishments[0].deathMode ? 25 : 10} XP)
</button>
      </div>
    </div>

    <style>{`
      @keyframes fadeIn {
        from {opacity: 0;}
        to {opacity: 1;}
      }
      @keyframes scaleIn {
        from {transform: scale(0.85); opacity: 0;}
        to {transform: scale(1); opacity: 1;}
      }
    `}</style>
  </div>
)}

  {showDurationModal && (
  <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-60 z-50">
    <div className="bg-gray-900 text-white p-6 rounded-2xl shadow-lg w-80 border border-purple-500">
      <h2 className="text-lg font-semibold mb-3 text-center">
        {durationType} Completed!
      </h2>
      <p className="text-sm text-gray-300 mb-3 text-center">
        How long did it take? (minutes)
      </p>
      <input
        type="number"
        className="w-full p-2 text-black rounded-lg focus:ring-2 focus:ring-purple-400 outline-none"
        value={durationMinutes}
        onChange={(e) => setDurationMinutes(e.target.value)}
        placeholder="Enter minutes"
      />
      <div className="flex justify-between mt-4">
        <button
          onClick={() => setShowDurationModal(false)}
          className="px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition"
        >
          Cancel
        </button>
        <button
          onClick={handleDurationSave}
          className="px-4 py-2 rounded-lg bg-purple-600 hover:bg-purple-700 transition"
        >
          Save
        </button>
      </div>
    </div>
  </div>
)}
{/* Architect Modal */}
{showArchitect && (
  <div id="architectModal" className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
    <div id="architectBox" className={`p-5 rounded w-full max-w-sm text-center shadow-lg border-2 ${architectMood === "positive" ? "bg-green-900 border-green-500" : "bg-red-900 border-red-500"}`}>
      <h2 className="text-xl font-bold mb-3">Architect's Judgment</h2>
      <pre className="mb-3 whitespace-pre-wrap text-left">{architectMessage}</pre>
      <button onClick={closeArchitectModal} className="bg-gray-700 px-4 py-2 rounded mt-3 w-full">Continue</button>
    </div>
  </div>
)}
      {showAnchorModal && currentAnchor && (
  <div className="fixed inset-0 z-50 flex items-center justify-center">
    <div className="absolute inset-0 bg-black/70"></div>

    <div className="relative bg-gray-900 text-white rounded-2xl p-6 w-80 max-w-[90%] shadow-2xl border border-purple-600/40 animate-fadeIn">
      <h3 className="text-lg font-bold mb-1">üïØÔ∏è {currentAnchor.label} Anchor</h3>
      <p className="text-sm mb-4">Did you honour your contracts today?</p>

      <div className="flex gap-3 justify-center">
        <button
          onClick={() => handleAnchorAnswer(true)}
          className="px-4 py-2 rounded-xl bg-emerald-500 hover:bg-emerald-600 transform transition hover:scale-105 shadow-md"
        >
          Yes
        </button>

        <button
          onClick={() => handleAnchorAnswer(false)}
          className="px-4 py-2 rounded-xl bg-red-500 hover:bg-red-600 transform transition hover:scale-105 shadow-md"
        >
          No
        </button>
      </div>

      <div className="mt-4 text-xs text-gray-300 text-center">
        (Auto-closes when you answer)
      </div>
    </div>
  </div>
)}

{showSettings && (
  <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
    <div className="bg-gray-900 rounded-2xl p-6 w-full max-w-md text-center border border-purple-500 shadow-2xl animate-fadeIn">
      <h2 className="text-2xl font-bold mb-4 text-purple-400">‚öôÔ∏è Settings</h2>

      <p className="text-gray-300 mb-3">Select Difficulty</p>
      <div className="flex justify-around mb-4">
        {["easy", "medium", "hard", "monarch"].map((mode) => (
          <button
            key={mode}
            onClick={() => applyPreset(mode)}
            className={`px-3 py-2 rounded-lg font-semibold ${
              difficulty === mode
                ? "bg-purple-600"
                : "bg-gray-700 hover:bg-gray-600"
            }`}
          >
            {mode.toUpperCase()}
          </button>
        ))}
      </div>

      <div className="text-left text-sm space-y-2 mb-4">
        <p>üß† Rival Daily XP: <b>{settings.rivalXP}</b></p>
        <p>üèõ Architect Threshold: <b>{settings.architectThreshold}%</b></p>
        <p>üå´ Fog Rate: <b>{settings.fogRate}x</b></p>
        <p>üíÄ Debt Penalty: <b>+{settings.debtPenalty}</b></p>
        <p>‚ú® Focus Reward: <b>+{settings.focusReward} XP</b></p>
      </div>

      <button
        onClick={() => setShowSettings(false)}
        className="bg-purple-700 hover:bg-purple-800 px-4 py-2 rounded-lg font-bold shadow-lg w-full"
      >
        Close
      </button>
    </div>
  </div>
)}
  {/* Architect Crystal Storage */}
<div className="mt-4 border-t border-gray-700 pt-3 text-left">
  <h3 className="text-lg font-semibold text-purple-400 mb-2">üíé Architect Crystals</h3>
  {architectCrystals.length === 0 && (
    <p className="text-gray-400 text-sm">No stored crystals yet.</p>
  )}
  {architectCrystals.map((c) => (
    <div
      key={c.id}
      className="flex justify-between items-center mb-1 text-sm text-gray-200"
    >
      <span>{c.reason} ({c.xpValue} XP)</span>
      <button
        onClick={() => useArchitectCrystal(c.id)}
        className="bg-purple-700 hover:bg-purple-800 px-2 py-1 rounded text-xs"
      >
        Absorb
      </button>
    </div>
  ))}
</div>

      {/* Daily Quest Modal */}
      {showDailyQuest && (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
          <div className="bg-gray-900 p-5 rounded w-full max-w-sm">
            <h2 className="text-lg mb-4 font-semibold text-center">Daily Quest</h2>
            {dailyQuestList.map((q,i)=>(
              <div key={i} className="flex justify-between mb-2 text-sm">
                <span>{q.title}</span>
                <button onClick={()=>toggleQuestDone(i)} className={`px-2 py-1 rounded ${q.done?"bg-green-500":"bg-blue-500"}`}>
                  {q.done?"Done":"Mark"}
                </button>
              </div>
            ))}
            <button onClick={failDailyQuest} className="bg-red-500 w-full py-2 mt-4 rounded">Fail Quest</button>
          </div>
        </div>
      )}
{/* Animation CSS */}
<style>{`
  @keyframes fadeIn {
    from {opacity: 0;}
    to {opacity: 1;}
  }
  @keyframes scaleIn {
    from {transform: scale(0.85); opacity: 0;}
    to {transform: scale(1); opacity: 1;}
  }
  @keyframes slideInUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  .animate-fadeIn { animation: fadeIn 0.3s ease forwards; }
  .animate-scaleIn { animation: scaleIn 0.3s ease forwards; }
  .animate-slideInUp { animation: slideInUp 0.4s ease forwards; }
`}</style>

{/* Tasks Section */}
<div className="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg max-w-md mx-auto">      
<div className="mt-5">
  <h2 className="text-lg mb-2 font-semibold">Tasks</h2>
  <div className="mb-3 flex justify-end">
    {!lockdown && (
      <button
        onClick={() => setShowAddModal(true)}
        className="bg-blue-500 px-3 py-1 rounded shadow-md hover:scale-105 hover:shadow-blue-500/50 transform transition-all duration-300"
      >
        + Add Task
      </button>
    )}
  </div>
  {tasks.length === 0 ? (
    <p className="text-center text-gray-400">No tasks yet.</p>
  ) : (
    tasks.map((task, i) => (
      <div
        key={task.id}
        className="bg-gray-800 p-3 rounded mb-2 flex justify-between items-center shadow-lg transform transition-all duration-300 hover:scale-[1.02] hover:shadow-xl animate-fadeIn animate-scaleIn"
        style={{ animationDelay: `${i * 0.05}s` }}
      >
        <div>
          <p className="font-bold text-sm">{task.title}</p>
          <p className="text-xs text-gray-400">
  {task.type === 'daily'
    ? `Time: ${task.start}-${task.end}`
    : getRemainingDays(task)}
</p>
          <p className="text-xs text-yellow-400">
      {taskTimers[task.id] || ""}
    </p>
        </div>
        {!lockdown && (
          <button
            onClick={() => completeTask(task.id)}
            className="bg-green-500 px-2 py-1 rounded text-sm hover:bg-green-600 hover:scale-105 transition-all duration-300"
          >
            Done
          </button>
        )}
      </div>
    ))
  )}
</div>

{/* Habits Section */}
<div className="mt-5">
  <h2 className="text-lg mb-2 font-semibold">Habits</h2>
  {habits.length === 0 ? (
    <p className="text-center text-gray-400">No habits yet.</p>
  ) : (
    habits.map((h, i) => (
      <div
        key={h.id}
        className="bg-gray-800 p-3 rounded mb-2 flex justify-between items-center text-sm shadow-lg transform transition-all duration-300 hover:scale-[1.02] hover:shadow-xl animate-fadeIn animate-scaleIn"
        style={{ animationDelay: `${i * 0.05}s` }}
      >
        <p className="font-bold">{h.title}</p>
        <div>
          <button
            onClick={() => completeHabit(h.id)}
            disabled={h.done || lockdown}
            className={`px-2 py-1 rounded transition-all duration-300 ${
              h.done
                ? 'bg-gray-500'
                : 'bg-green-500 hover:bg-green-600 hover:scale-105'
            }`}
          >
            {h.done ? 'Done' : 'Mark'}
          </button>
          {!lockdown && (
            <button
              onClick={() => deleteHabit(h.id)}
              className="bg-red-500 px-2 py-1 ml-1 rounded hover:bg-red-600 hover:scale-105 transition-all duration-300"
            >
              Delete
            </button>
          )}
        </div>
      </div>
    ))
  )}
</div>

{/* Add Task Modal */}
{showAddModal && (
  <div className="fixed inset-0 flex items-center justify-center z-50 p-4 animate-fadeIn">
    {/* Background Overlay */}
    <div
      className="absolute inset-0 bg-black/70 backdrop-blur-sm"
      onClick={() => setShowAddModal(false)}
    ></div>

    {/* Modal Box */}
    <div className="relative bg-gray-900 p-5 rounded w-full max-w-sm transform animate-scaleIn shadow-xl z-10">
      <h2 className="text-lg mb-4 font-semibold">Add Task</h2>
      <select
        value={newTask.type}
        onChange={e => setNewTask({ ...newTask, type: e.target.value })}
        className="mb-3 w-full p-2 text-black rounded"
      >
        <option value="daily">Daily</option>
        <option value="timed">Timed</option>
        <option value="habit">Habit</option>
      </select>
      <input
        value={newTask.title}
        onChange={e => setNewTask({ ...newTask, title: e.target.value })}
        placeholder="Task Title"
        className="mb-3 w-full p-2 text-black rounded"
      />
      {newTask.type === 'daily' && (
        <div className="flex gap-2 mb-3">
          <input
            type="time"
            value={newTask.start}
            onChange={e => setNewTask({ ...newTask, start: e.target.value })}
            className="p-2 text-black rounded w-1/2"
          />
          <input
            type="time"
            value={newTask.end}
            onChange={e => setNewTask({ ...newTask, end: e.target.value })}
            className="p-2 text-black rounded w-1/2"
          />
        </div>
      )}
      {newTask.type === 'timed' && (
        <input
          type="number"
          placeholder="Days"
          value={newTask.days}
          onChange={e => setNewTask({ ...newTask, days: e.target.value })}
          className="mb-3 w-full p-2 text-black rounded"
        />
      )}
      <div className="flex gap-2">
        <button
          onClick={addTask}
          className="bg-blue-500 flex-1 py-2 rounded text-white hover:bg-blue-600 transition"
        >
          Add
        </button>
        <button
          onClick={() => setShowAddModal(false)}
          className="bg-red-500 flex-1 py-2 rounded text-white hover:bg-red-600 transition"
        >
          Cancel
        </button>
      </div>
    </div>
  </div>
)}
</div>
<div className="daily-reflection-card">
  <h2 className="dr-title">Daily Reflection</h2>

<div className="chat-box">
  <textarea
    className="chat-input"
    placeholder="Write your question‚Ä¶"
    value={dailyQuestion}
    onChange={(e) => {
      setDailyQuestion(e.target.value);
      localStorage.setItem("dailyQuestion", e.target.value);
    }}
    readOnly={questionDone}
  />
</div>
<div className="chat-box">
  <textarea
    className="chat-input"
    placeholder="Write your answer‚Ä¶"
    value={dailyAnswer}
    onChange={(e) => {
      setDailyAnswer(e.target.value);
      localStorage.setItem("dailyAnswer", e.target.value);
    }}
    readOnly={questionDone}
  />
</div>

  <button
    className="complete-btn"
    disabled={questionDone}
    onClick={() => {
      setQuestionDone(true);
      localStorage.setItem("questionDone", "true");
    }}
  >
    {questionDone ? "Completed ‚úì" : "Mark as Completed"}
  </button>
</div>
      
      <HistoryCalendar 
    debt={debt} 
    onSelectDay={(day) => setSelectedHistoryDay(day)} 
/>
{selectedHistoryDay && (
  <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
    <div className="bg-gray-800 p-6 rounded-xl shadow-lg w-full max-w-md text-white relative max-h-[90vh] overflow-y-auto">
      <button
        className="absolute top-2 right-2 text-gray-400 hover:text-white"
        onClick={() => setSelectedHistoryDay(null)}
      >
        ‚úñ
      </button>
      <h3 className="text-lg font-bold mb-3">üìÖ {selectedHistoryDay.date}</h3>
      <p><strong>XP:</strong> {selectedHistoryDay.xp}</p>
      <p><strong>Level:</strong> {selectedHistoryDay.level}</p>
      <p><strong>Fog Level:</strong> {selectedHistoryDay.fogLevel}%</p>
      <p>
        <strong>Daily Quest:</strong>{" "}
        {selectedHistoryDay.dailyQuestCompleted ? "‚úÖ Completed" : "‚ùå Failed"}
      </p>
      
      <p>
  <strong>Wake Up:</strong>{" "}
  {selectedHistoryDay.wakeUpOnTime ? "‚úÖ On Time" : "‚ùå Late/Not Logged"}
</p>
<p>
  <strong>Mock Percentile:</strong> {selectedHistoryDay.mockPercentile || 0}%
</p>
       <div className="mt-3">
    <h4 className="font-semibold">‚úÖ Tasks Completed:</h4>
    <ul className="list-disc list-inside text-sm">
      {selectedHistoryDay.tasksCompleted.map((t, idx) => (
        <li key={idx}>{t}</li>
      ))}
    </ul>
  </div>

    </div>
  </div>
)}
      
    </div>   
  );         
}            
      
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>   
      
