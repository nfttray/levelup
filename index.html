<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Solo Leveling Grind</title>
  <link rel="icon" href="https://upload.wikimedia.org/wikipedia/en/2/23/Solo_Leveling_logo.png" type="image/png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: url('https://wallpapercave.com/wp/wp9420280.jpg') no-repeat center center fixed;
      background-size: cover;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: -1;
    }
    .flash { animation: flashEffect 1s ease-in-out; }
    @keyframes flashEffect {
      0% { background-color: rgba(255,255,255,0.4); }
      100% { background-color: transparent; }
    }
  </style>
</head>
<body class="text-white">
<div class="overlay"></div>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect } = React;

// === CONSTANTS ===
const normalPunishments = [
  "Solve 50 maths questions", "Solve 100 GK questions", "Revise 2 topics",
  "No social media 6 hrs", "Full mock analysis"
];
const deathModePunishments = [
  "Study 6 hrs straight + summary", "200 questions + 50 push-ups",
  "Watch 4-5 videos continue and learn", "2 Full mock test now + No phone 8 hrs + analysis", "Revise 8 topics + Cold shower"
];
const rewards = [
  "Watch 1 anime episode", "Eat favorite snack", "Listen to music", "Take a relaxing walk", "watch insta for 20 mins"
];

// === DAILY QUEST EXERCISES (7 Days) ===
const weeklyQuestExercises = [
  ["Curl Bar Overhead Press â€“ 4 Ã— 12","Dumbbell Lateral Raise â€“ 4 Ã— 15","Dumbbell Shrugs â€“ 3 Ã— 20","Reverse Fly â€“ 3 Ã— 15","Yoga: Bhujangasana â€“ 2 Ã— 30 sec"],
  ["Curl Bar Bicep Curl â€“ 4 Ã— 12","Hammer Curl â€“ 3 Ã— 15","Overhead Dumbbell Tricep Extension â€“ 3 Ã— 12","Push-Ups â€“ 3 Ã— max","Yoga: Tadasana â€“ 1 min"],
  ["Dumbbell Side Bend â€“ 4 Ã— 20 each","Russian Twist â€“ 3 Ã— 30 sec","Dumbbell Pullover â€“ 4 Ã— 12","Plank Hold â€“ 3 Ã— 40 sec","Yoga: Setu Bandhasana â€“ 2 Ã— 30 sec"],
  ["Scapular Retraction â€“ 3 Ã— 12","Reverse Fly â€“ 3 Ã— 15","Dumbbell Front Raise â€“ 3 Ã— 12","Dumbbell Shrugs â€“ 3 Ã— 20","Yoga: Anulom Vilom â€“ 2 min"],
  ["Overhead Press + Curl Superset â€“ 3 Ã— 12","Lateral Raise + Shrugs â€“ 3 rounds","Close-Grip Push-Ups â€“ 3 Ã— max","Hammer Curl â€“ 3 Ã— 15","Yoga: Surya Namaskar â€“ 3 rounds"],
  ["Surya Namaskar â€“ 4 rounds","Bhujangasana + Shalabhasana â€“ 3 Ã— 30 sec","Vrikshasana â€“ 2 Ã— 30 sec","Bridge Pose â€“ 3 Ã— 30 sec","Kapalbhati â€“ 1 min"],
  ["Cat-Cow Stretch â€“ 2 min","Wall Angel â€“ 3 Ã— 10","Anulom Vilom â€“ 2 min","Forward Bend Stretch â€“ 2 Ã— 20 sec","Childâ€™s Pose â€“ 2 Ã— 30 sec"]
];

  const fogIncreaseOptions = [
  "Mindless scrolling",
  "Negative self-talk",
  "Skipping exercise",
  "Poor sleep",
  "Porn or instant gratification",
  "Avoiding tasks",
  "Unhealthy food",
  "Watching drama/TV",
  "Overthinking",
  "Unclear goals",
  "Too much comfort"
];

const fogReduceOptions = [
  "Cold shower",
  "Breathing exercise",
  "Meditation",
  "Shadow work",
  "Reading spiritual book",
  "Walking outdoors",
  "Doing deep work",
  "Helping others",
  "Waking early",
  "Writing journal",
  "Sunlight"
];

// === XP SYSTEM ===
const rankTitles = ['E-Rank Hunter','D-Rank','C-Rank','B-Rank','A-Rank','S-Rank'];
const characterImages = [
  'https://cdn.jsdelivr.net/gh/Ashwinvalento/cartoon-avatar@master/lib/images/male/45.png',
  'https://cdn.jsdelivr.net/gh/Ashwinvalento/cartoon-avatar@master/lib/images/male/20.png',
  'https://cdn.jsdelivr.net/gh/Ashwinvalento/cartoon-avatar@master/lib/images/female/68.png',
  'https://cdn.jsdelivr.net/gh/Ashwinvalento/cartoon-avatar@master/lib/images/female/21.png'
];

function getXPForLevel(level){ return level*level*100; }
function getRank(level){
  if(level<5)return rankTitles[0];
  if(level<10)return rankTitles[1];
  if(level<15)return rankTitles[2];
  if(level<20)return rankTitles[3];
  if(level<25)return rankTitles[4];
  return rankTitles[5];
}

// Rival XP constants
const DAILY_RIVAL_XP = 30;
const HOURLY_RIVAL_XP = 1.25;

  // === MAIN APP ===
function App(){
  const [xp,setXP]=useState(parseInt(localStorage.getItem('xp'))||0);
  const [level,setLevel]=useState(parseInt(localStorage.getItem('level'))||1);
  const [tasks,setTasks]=useState(JSON.parse(localStorage.getItem('tasks'))||[]);
  const [taskLog, setTaskLog] = useState(JSON.parse(localStorage.getItem('taskLog')) || []);
  const [habits,setHabits]=useState(JSON.parse(localStorage.getItem('habits'))||[]);
  const [punishments,setPunishments]=useState(JSON.parse(localStorage.getItem('punishments'))||[]);
  const [showAddModal,setShowAddModal]=useState(false);
  const [newTask,setNewTask]=useState({type:'daily',title:'',start:'',end:'',days:''});
  const [bossCountdown,setBossCountdown]=useState(parseInt(localStorage.getItem('bossCountdown'))||0);
  const [rivalXP,setRivalXP]=useState(parseFloat(localStorage.getItem('rivalXP'))||0);
  const [rivalLevel,setRivalLevel]=useState(parseInt(localStorage.getItem('rivalLevel'))||1);
  const [behindDays,setBehindDays]=useState(parseInt(localStorage.getItem('behindDays'))||0);
  const [showLevelUp,setShowLevelUp]=useState(false);
  const [lockdown,setLockdown]=useState(false);
  const [timer,setTimer]=useState(getRemainingBossTime());
  const [showDailyQuest,setShowDailyQuest]=useState(false);
  const [dailyQuestList,setDailyQuestList]=useState([]);
  const [dopamineActive, setDopamineActive] = useState(JSON.parse(localStorage.getItem('dopamineActive')) || false);
  const [dopamineLevel, setDopamineLevel] = useState(parseFloat(localStorage.getItem('dopamineLevel')) || 100);
  const [showUrgeModal, setShowUrgeModal] = useState(false);
  const [urgeTask, setUrgeTask] = useState('');
  const urgeTasks = [
  "Do 10 push-ups now!",
  "sleep on left side.",
  "Take 10 deep breaths.",
  "Drink a glass of water.",
  "Do 10 squat."
   ];
  const [fogLevel, setFogLevel] = useState(20); // Starts at 20%
  const [fogReason, setFogReason] = useState('');

  function triggerUrgeRedirect() {
  setUrgeTask(urgeTasks[Math.floor(Math.random() * urgeTasks.length)]);
  setShowUrgeModal(true);

  // Auto complete after 10 sec
  setTimeout(() => {
    if (showUrgeModal) {
      handleUrgeComplete();
    }
  }, 10000);
  }
  function handleUrgeComplete() {
  setShowUrgeModal(false);
  setXP(prevXP => prevXP + 3); // Reward +3 XP
}

function handleUrgeSkip() {
  setShowUrgeModal(false);
  setXP(prevXP => Math.max(0, prevXP - 5)); // -5 XP
  setRivalXP(prev => prev + 5); // Rival +5 XP
    }
  // === RELAPSE ===
  function handleRelapse(){
    if(confirm("Are you sure? Relapse will cost 50 XP!")){
      setXP(Math.max(0,xp-50));
    }
  }

  function checkTaskDeadlines() {
  const now = new Date();
  let updatedTasks = [...tasks];
  let missedTasks = [];

  updatedTasks.forEach(task => {
    if (!task.done) {  // Ensure we only check incomplete tasks
      if (task.type === 'daily') {
        const [endH, endM] = task.end.split(':');
        const endTime = new Date();
        endTime.setHours(endH, endM, 0, 0);

        if (now > endTime) missedTasks.push(task);
      } else if (task.type === 'timed') {
        const createdDate = new Date(task.created);
        const deadline = new Date(createdDate);
        deadline.setDate(createdDate.getDate() + parseInt(task.days || 0));
        if (now > deadline) missedTasks.push(task);
      }
    }
  });

  if (missedTasks.length > 0) {
    // Remove missed tasks
    updatedTasks = updatedTasks.filter(t => !missedTasks.includes(t));
    setTasks(updatedTasks);

    // Lockdown and punishment
    missedTasks.forEach(task => {
      const randomPunishment = normalPunishments[Math.floor(Math.random() * normalPunishments.length)];
addPunishment({
  type: 'taskMissed',
  text: `You missed: ${task.title}\nPunishment: ${randomPunishment}`,
  deathMode: false
});
      
    });
  }
  }
  // === BOSS TIMER ===
  function startBossTimer(hours){
    const endTime=Date.now()+hours*60*60*1000;
    localStorage.setItem('bossEndTime',endTime);
    setTimer(endTime-Date.now());
  }
  function getRemainingBossTime(){
    const endTime=parseInt(localStorage.getItem('bossEndTime'))||0;
    const now=Date.now();
    return Math.max(0,endTime-now);
  }
  function formatTime(ms){
    const totalSeconds=Math.floor(ms/1000);
    const hrs=Math.floor(totalSeconds/3600);
    const mins=Math.floor((totalSeconds%3600)/60);
    const secs=totalSeconds%60;
    return `${hrs}h ${mins}m ${secs}s`;
  }
// === Decay System Effect ===

  
  // === Timer Update ===
  useEffect(()=>{
    const interval=setInterval(()=>{ setTimer(getRemainingBossTime()); },1000);
    return()=>clearInterval(interval);
  },[]);

  useEffect(() => {
  const interval = setInterval(checkTaskDeadlines, 30000); // check every 30 sec
  return () => clearInterval(interval);
}, [tasks]);

  
 useEffect(() => {
  const today = new Date();
  let lastDungeonDate = localStorage.getItem('lastDungeonDate');

  if (!lastDungeonDate) {
    localStorage.setItem('lastDungeonDate', today);
    lastDungeonDate = today;
  }

  const diffDays = Math.floor((today - new Date(lastDungeonDate)) / (1000 * 60 * 60 * 24));

  if (diffDays >= 10 && !punishments.some(p => p.type === 'dungeon')) {
    addPunishment({
      type: 'dungeon',
      text: "Dungeon Boss! Complete 20 tasks within 24 hrs!",
      deathMode: true
    });
    startBossTimer(24); // 24 hrs for challenge
    localStorage.setItem('lastDungeonDate', today);
    setTaskLog([]); // Reset log for tracking new tasks
  }
}, [punishments]);
  // === SAVE DATA ===
  useEffect(()=>{
    localStorage.setItem('xp',xp);
    localStorage.setItem('level',level);
    localStorage.setItem('tasks',JSON.stringify(tasks));
    localStorage.setItem('habits',JSON.stringify(habits));
    localStorage.setItem('punishments',JSON.stringify(punishments));
    localStorage.setItem('bossCountdown',bossCountdown);
    localStorage.setItem('rivalXP',rivalXP);
    localStorage.setItem('rivalLevel',rivalLevel);
    localStorage.setItem('taskLog', JSON.stringify(taskLog));
    localStorage.setItem('behindDays',behindDays);
    localStorage.setItem('dailyQuestList',JSON.stringify(dailyQuestList));
  },[xp,level,tasks,habits,punishments,bossCountdown,rivalXP,rivalLevel,behindDays,dailyQuestList]);

  // === LEVEL UP ===
  useEffect(()=>{
    if(xp>=getXPForLevel(level)){
      setXP(xp-getXPForLevel(level));
      setLevel(level+1);
      setShowLevelUp(true);
      setTimeout(()=>setShowLevelUp(false),2000);
    }
  },[xp]);

  // Dopamine Detox System
useEffect(() => {
  let interval;
  if (dopamineActive && dopamineLevel > 0) {
    interval = setInterval(() => {
      setDopamineLevel(prev => {
        const newLevel = Math.max(prev - (100 / (2 * 60 * 60)), 0);
        localStorage.setItem('dopamineLevel', newLevel);
        return newLevel;
      });
    }, 1000);
  }
  return () => clearInterval(interval);
}, [dopamineActive]);

// Save toggle state
useEffect(() => {
  localStorage.setItem('dopamineActive', JSON.stringify(dopamineActive));
}, [dopamineActive]);

// Penalty when dopamine hits 0
useEffect(() => {
  if (dopamineLevel === 0) {
    alert("âš ï¸ Dopamine depleted! Apply punishment now!");
    setDopamineActive(false);
    // Optional: Trigger punishment system
    addPunishment({
      type: 'dopamineFail',
      text: "Dopamine Bar Empty! Punishment: Solve 100 questions + No social media 6 hrs",
      deathMode: true
    });
  }
}, [dopamineLevel]);

  useEffect(() => {
  const today = new Date().toLocaleDateString();
  const lastFogReset = localStorage.getItem("fogReset");

  if (lastFogReset !== today) {
    setFogLevel(20);
    localStorage.setItem("fogReset", today);
  }
}, []);

  useEffect(() => {
  // Fog level penalty/reward at end of day
  const today = new Date().toLocaleDateString();
  const lastCheck = localStorage.getItem("fogDate");
  if (lastCheck !== today) {
    if (fogLevel > 70) {
      setXP(prev => Math.max(0, prev - 5));
    } else if (fogLevel < 30) {
      setXP(prev => prev + 5);
    }
    localStorage.setItem("fogDate", today);
  }
}, []);
  // Boss Fight Check
useEffect(() => {
  // === Small Boss after 7 tasks ===
  if (bossCountdown >= 7 && !punishments.some(p => p.type === 'boss')) {
    addPunishment({
  type: 'boss',
  text: "Revision Boss Fight! Complete within 3 hrs!",
  deathMode: true
});
    startBossTimer(3); // 3 hrs
    setBossCountdown(0);
  }

  // === Weekly Boss every Sunday ===
  const today = new Date().getDay();
  if (today === 0 && localStorage.getItem('weeklyBossTriggered') !== 'true') {
  const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
  addPunishment({
    type: 'weeklyBoss',
    text: `Dont die until its Complete within 10 hrs!\nPunishment: ${randomDeathPunishment}`,
    deathMode: true
  });
  startBossTimer(10); // 10 hrs timer
  localStorage.setItem('weeklyBossTriggered', 'true');
  }
  if (today !== 0) {
    localStorage.setItem('weeklyBossTriggered', 'false');
  }

  // === Dungeon Boss if 20 tasks in 24 hrs ===
  if (taskLog.length >= 20 && !punishments.some(p => p.type === 'dungeon')) {
    addPunishment({
      type: 'dungeon',
      text: "Dungeon Boss! Complete within 24 hrs!",
      deathMode: true
    });
    startBossTimer(24);
    setTaskLog([]); // reset dungeon log
  }
}, [bossCountdown, taskLog]);

  useEffect(() => {
  const interval = setInterval(() => {
    const remaining = getRemainingBossTime();
    setTimer(remaining);

    if (remaining <= 0 && punishments.length > 0) {
      const current = punishments[0];
      if (['boss', 'weeklyBoss', 'dungeon'].includes(current.type)) {
        // Boss failed
        setXP(Math.max(0, xp - 30)); // Penalty
        setRivalXP(prev => prev + 20); // Rival advantage
        completePunishment(); // Remove boss punishment
      }
    }
  }, 1000);
  return () => clearInterval(interval);
}, [punishments]);

  // === Rival XP Auto Update ===
useEffect(() => {
  const updateRivalXP = () => {
    const now = Date.now();
    const lastUpdate = parseInt(localStorage.getItem('lastRivalUpdate')) || now;
    const hoursPassed = Math.floor((now - lastUpdate) / 3600000);

    if (hoursPassed > 0) {
      const daysPassed = Math.floor(hoursPassed / 24);
      const extraHours = hoursPassed % 24;

      const gainedXP = (daysPassed * DAILY_RIVAL_XP) + (extraHours * HOURLY_RIVAL_XP);

      setRivalXP(prevXP => {
        let newXP = prevXP + gainedXP;
        let level = rivalLevel;

        while (newXP >= getXPForLevel(level)) {
          newXP -= getXPForLevel(level);
          level++;
        }

        setRivalLevel(level);
        return newXP;
      });

      localStorage.setItem('lastRivalUpdate', now);
    }
  };

  updateRivalXP();
  const interval = setInterval(updateRivalXP, 3600000);
  return () => clearInterval(interval);
}, []);
  

  useEffect(() => {
  const now = Date.now();
  const lastCheck = parseInt(localStorage.getItem('last3DayCheck')) || 0;
  const diffDays = Math.floor((now - lastCheck) / (1000 * 60 * 60 * 24));

  if (diffDays >= 3) {
    // Update last check date
    localStorage.setItem('last3DayCheck', now);

    // Check if rival is ahead
    const rivalAhead = rivalLevel > level || (rivalLevel === level && rivalXP > xp);

    if (rivalAhead) {
      const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
      addPunishment({
        type: 'deathRival',
        text: `Rival is ahead after 3 days! Punishment: ${randomDeathPunishment}`,
        deathMode: true
      });
    }
  }
}, [xp, level, rivalXP, rivalLevel]);

  // === Daily Quest System ===
  useEffect(() => {
    const today = new Date().toDateString();
    const lastReset = localStorage.getItem('lastQuestReset');
    const todayIndex = new Date().getDay();
    if (lastReset !== today) {
      const resetQuests = (weeklyQuestExercises[todayIndex] || weeklyQuestExercises[0])
        .map(e => ({ title: e, done: false }));
      setDailyQuestList(resetQuests);
      localStorage.setItem('lastQuestReset', today);
      localStorage.setItem('dailyQuestList', JSON.stringify(resetQuests));
      setShowDailyQuest(true);
    } else {
      const saved = JSON.parse(localStorage.getItem('dailyQuestList')) || [];
      setDailyQuestList(saved);
      setShowDailyQuest(!saved.every(q => q.done));
    }
  }, []);

  function toggleQuestDone(index){
    const updated=[...dailyQuestList];
    updated[index].done=!updated[index].done;
    setDailyQuestList(updated);
    localStorage.setItem('dailyQuestList',JSON.stringify(updated));
    if(updated.every(q=>q.done)){
      setShowDailyQuest(false);
      setXP(xp+10);
    }
  }

  function failDailyQuest(){
  setShowDailyQuest(false);
  const randomDeathPunishment = deathModePunishments[Math.floor(Math.random() * deathModePunishments.length)];
  addPunishment({
    type: 'questFail',
    text: `Daily Quest Failed! Punishment: ${randomDeathPunishment}`,
    deathMode: true
  });
  }

  // === Add / Complete Tasks ===
  function addPunishment(p){
    setPunishments([...punishments,p]);
    setLockdown(true);
  }

  function completePunishment(){
    const [first,...rest]=punishments;
    let gain=0;
    if(first.type==='boss')gain=4;
    if(first.type==='weeklyBoss')gain=10;
    if(first.type==='dungeon')gain=20;
    setXP(xp+gain);
    if(['boss','weeklyBoss','dungeon'].includes(first.type)){
      setRivalXP(prev=>prev+Math.floor(gain/2));
    }
    if(first.deathMode){
      alert(`Reward: ${rewards[Math.floor(Math.random()*rewards.length)]}`);
    }
    setPunishments(rest);
    if(rest.length===0)setLockdown(false);
  }

  function forgivePunishment() {
  const current = punishments[0];
  let penalty = current.deathMode ? 25 : 10; // DeathMode = 25 XP, Normal = 10 XP

  // Subtract XP but not below 0
  setXP(prevXP => Math.max(0, prevXP - penalty));

  // Rival gains XP equal to penalty
  setRivalXP(prev => prev + penalty);

  // Remove punishment without giving reward
  const [, ...rest] = punishments;
  setPunishments(rest);

  // If no punishments left, disable lockdown
  if (rest.length === 0) setLockdown(false);
}

  function addTask(){
    if(!newTask.title)return;
    const id=Date.now();
    const task={...newTask,id,done:false,created:new Date().toISOString()};
    if(newTask.type==='habit'){setHabits([...habits,task]);}
    else{setTasks([...tasks,task]);}
    setShowAddModal(false);
    setNewTask({type:'daily',title:'',start:'',end:'',days:''});
  }

  function completeTask(id) {
  const completedTask = tasks.find(t => t.id === id);
  setTasks(tasks.filter(t => t.id !== id));
  setXP(xp + 2);

  // Add to task log (for small boss reference)
  const updatedLog = [...taskLog, completedTask.title].slice(-7); // Keep only last 7
  setTaskLog(updatedLog);

  // If Dungeon Boss active, still track separately for 20-task logic
  if (punishments.some(p => p.type === 'dungeon')) {
    if (updatedLog.length >= 20) {
      completePunishment(); // Dungeon Boss Cleared
    }
  }

  setBossCountdown(bossCountdown + 1);
    }

  function completeHabit(id){
    const updated=habits.map(h=>h.id===id?{...h,done:true}:h);
    setHabits(updated);
    setXP(xp+1);
  }

  function deleteHabit(id){setHabits(habits.filter(h=>h.id!==id));}

  return (
    <div className={"p-4 max-w-md mx-auto bg-black bg-opacity-70 rounded-lg mt-4 shadow-lg "+(showLevelUp?'flash':'')}>
      {/* Header */}
      <header className="text-center mb-4">
        <h1 className="text-2xl font-bold">SHADOW ARISE</h1>
        <p className="mt-1">Level {level} ({getRank(level)})</p>
        <div className="w-full bg-gray-700 rounded h-3 mt-2 overflow-hidden">
          <div className="bg-gradient-to-r from-blue-500 to-purple-600 h-3 rounded" style={{width:`${(xp/getXPForLevel(level))*100}%`}}></div>
        </div>
        <p className="text-sm mt-1">{xp} / {getXPForLevel(level)} XP</p>
        <img src={characterImages[Math.min(level-1,characterImages.length-1)]} className="mx-auto w-24 mt-3 rounded-full border-2 border-purple-400"/>
        <p className="mt-2 text-sm">Rival: Level {rivalLevel} | XP: {Math.floor(rivalXP)}</p>
        <p className="mt-1 text-sm font-bold">
  {rivalLevel > level || (rivalLevel === level && rivalXP > xp)
    ? "ðŸ”¥ Rival is ahead of you!"
    : "âœ… You are ahead of your rival"}
</p>
        <button onClick={handleRelapse} className="bg-red-500 mt-3 px-4 py-2 rounded w-full">Relapse (-50 XP)</button>
        {/* Urge Redirect Button */}
<button
  onClick={triggerUrgeRedirect}
  className="bg-purple-500 mt-3 px-4 py-2 rounded w-full"
>
  I Have an Urge
</button>


{/* Urge Modal */}
{showUrgeModal && (
  <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
    <div className="bg-gray-800 p-5 rounded text-center max-w-sm">
      <h2 className="text-xl font-bold mb-3">Redirect Your Urge</h2>
      <p className="mb-4">{urgeTask}</p>
      <p className="text-red-400 mb-3">Wait for 10 seconds...</p>
      <div className="flex gap-3 justify-center">
        <button
          onClick={handleUrgeComplete}
          className="bg-green-500 px-4 py-2 rounded"
        >
          Done (+3 XP)
        </button>
        <button
          onClick={handleUrgeSkip}
          className="bg-red-500 px-4 py-2 rounded"
        >
          Skip (-5 XP)
        </button>
      </div>
    </div>
  </div>
)}
      </header>
        
      {/* Dopamine Detox Section */}
<div className="mt-5">
  <h2 className="text-lg mb-2 font-semibold">Dopamine Detox</h2>
  <div className="flex justify-between items-center mb-2">
    <span>Detox Mode</span>
    <label className="switch">
      <input
        type="checkbox"
        checked={dopamineActive}
        onChange={() => setDopamineActive(!dopamineActive)}
      />
      <span className="slider round"></span>
    </label>
  </div>
  <div className="w-full bg-gray-700 rounded h-3 mt-2 overflow-hidden">
    <div
      className="bg-green-500 h-3"
      style={{ width: `${dopamineLevel}%` }}
    ></div>
  </div>
  <p className="text-sm mt-1">Dopamine Level: {dopamineLevel.toFixed(1)}%</p>
</div>

      <div className="mt-5">
  <h2 className="text-lg mb-2 font-semibold">Fog Meter</h2>
  <div className="w-full bg-gray-700 rounded h-3 mt-2 overflow-hidden">
    <div
      className={`h-3 ${fogLevel < 40 ? 'bg-green-500' : fogLevel < 70 ? 'bg-yellow-500' : 'bg-red-500'}`}
      style={{ width: `${fogLevel}%` }}
    ></div>
  </div>
  <p className="text-sm mt-1">Fog Level: {fogLevel.toFixed(0)}%</p>

  {/* Fog Reason Dropdown */}
  <div className="mt-3">
    <p className="text-sm font-semibold mb-1">Adjust Fog Level</p>
    <select
      onChange={(e) => setFogReason(e.target.value)}
      className="w-full text-black p-2 rounded"
      value={fogReason}
    >
      <option value="">-- Select a reason --</option>
      <optgroup label="Increase Fog">
        {fogIncreaseOptions.map((item, index) => (
          <option key={`inc-${index}`} value={`inc-${item}`}>{item}</option>
        ))}
      </optgroup>
      <optgroup label="Reduce Fog">
        {fogReduceOptions.map((item, index) => (
          <option key={`dec-${index}`} value={`dec-${item}`}>{item}</option>
        ))}
      </optgroup>
    </select>

    {fogReason && (
      <button
        className="bg-blue-500 mt-2 px-4 py-2 rounded w-full"
        onClick={() => {
          if (fogReason.startsWith("inc-")) {
            setFogLevel(Math.min(100, fogLevel + 5));
          } else {
            setFogLevel(Math.max(0, fogLevel - 5));
          }
          setFogReason('');
        }}
      >
        Confirm
      </button>
    )}
  </div>
</div>
      {/* Punishment Modal */}
      {punishments.length>0 && (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4">
          <div className="bg-gray-800 p-5 rounded w-full max-w-sm text-center">
            <h2 className="text-xl font-bold mb-3">Punishment</h2>
            <pre className="mb-3 whitespace-pre-wrap text-left">{punishments[0].text}</pre>
            {/* Show last 7 tasks for Small Boss */}
{punishments[0].type === 'boss' && taskLog.length > 0 && (
  <div className="text-left mb-3">
    <h3 className="font-semibold mb-1">Last 7 Tasks:</h3>
    <ul className="list-disc list-inside text-sm">
      {taskLog.slice(-7).map((t, i) => (
        <li key={i}>{t}</li>
      ))}
    </ul>
  </div>
)}
            {['boss','weeklyBoss','dungeon'].includes(punishments[0].type) && (
              <p className="mt-2 text-red-400 text-lg font-bold">Time Left: {formatTime(timer)}</p>
            )}
            <div className="flex flex-col gap-2 mt-4">
              <button onClick={completePunishment} className="bg-green-500 py-2 rounded">Complete</button>
              <button 
  onClick={forgivePunishment} 
  className="bg-yellow-500 py-2 rounded"
>
  Forgive (-{punishments[0].deathMode ? 25 : 10} XP)
</button>
            </div>
          </div>
        </div>
      )}

      {/* Daily Quest Modal */}
      {showDailyQuest && (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
          <div className="bg-gray-900 p-5 rounded w-full max-w-sm">
            <h2 className="text-lg mb-4 font-semibold text-center">Daily Quest</h2>
            {dailyQuestList.map((q,i)=>(
              <div key={i} className="flex justify-between mb-2 text-sm">
                <span>{q.title}</span>
                <button onClick={()=>toggleQuestDone(i)} className={`px-2 py-1 rounded ${q.done?"bg-green-500":"bg-blue-500"}`}>
                  {q.done?"Done":"Mark"}
                </button>
              </div>
            ))}
            <button onClick={failDailyQuest} className="bg-red-500 w-full py-2 mt-4 rounded">Fail Quest</button>
          </div>
        </div>
      )}

      {/* Tasks Section */}
      <div className="mt-5">
        <h2 className="text-lg mb-2 font-semibold">Tasks</h2>
        <div className="mb-3 flex justify-end">
          {!lockdown && (
            <button onClick={()=>setShowAddModal(true)} className="bg-blue-500 px-3 py-1 rounded">+ Add Task</button>
          )}
        </div>
        {tasks.length===0?(
          <p className="text-center text-gray-400">No tasks yet.</p>
        ):(
          tasks.map(task=>(
            <div key={task.id} className="bg-gray-800 p-3 rounded mb-2 flex justify-between items-center">
              <div>
                <p className="font-bold text-sm">{task.title}</p>
                <p className="text-xs text-gray-400">{task.type==='daily'?`Time: ${task.start}-${task.end}`:`Deadline: ${task.days} days`}</p>
              </div>
              {!lockdown && (
                <button onClick={()=>completeTask(task.id)} className="bg-green-500 px-2 py-1 rounded text-sm">Done</button>
              )}
            </div>
          ))
        )}
      </div>

      {/* Habits Section */}
      <div className="mt-5">
        <h2 className="text-lg mb-2 font-semibold">Habits</h2>
        {habits.length===0?(
          <p className="text-center text-gray-400">No habits yet.</p>
        ):(
          habits.map(h=>(
            <div key={h.id} className="bg-gray-800 p-3 rounded mb-2 flex justify-between items-center text-sm">
              <p className="font-bold">{h.title}</p>
              <div>
                <button onClick={()=>completeHabit(h.id)} disabled={h.done||lockdown} className={`px-2 py-1 rounded ${h.done?"bg-gray-500":"bg-green-500"}`}>
                  {h.done?"Done":"Mark"}
                </button>
                {!lockdown && (
                  <button onClick={()=>deleteHabit(h.id)} className="bg-red-500 px-2 py-1 ml-1 rounded">Delete</button>
                )}
              </div>
            </div>
          ))
        )}
      </div>

      {/* Add Task Modal */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
          <div className="bg-gray-900 p-5 rounded w-full max-w-sm">
            <h2 className="text-lg mb-4 font-semibold">Add Task</h2>
            <select value={newTask.type} onChange={e=>setNewTask({...newTask,type:e.target.value})} className="mb-3 w-full p-2 text-black rounded">
              <option value="daily">Daily</option>
              <option value="timed">Timed</option>
              <option value="habit">Habit</option>
            </select>
            <input value={newTask.title} onChange={e=>setNewTask({...newTask,title:e.target.value})} placeholder="Task Title" className="mb-3 w-full p-2 text-black rounded"/>
            {newTask.type==='daily' && (
              <div className="flex gap-2 mb-3">
                <input type="time" value={newTask.start} onChange={e=>setNewTask({...newTask,start:e.target.value})} className="p-2 text-black rounded w-1/2"/>
                <input type="time" value={newTask.end} onChange={e=>setNewTask({...newTask,end:e.target.value})} className="p-2 text-black rounded w-1/2"/>
              </div>
            )}
            {newTask.type==='timed' && (
              <input type="number" placeholder="Days" value={newTask.days} onChange={e=>setNewTask({...newTask,days:e.target.value})} className="mb-3 w-full p-2 text-black rounded"/>
            )}
            <div className="flex gap-2">
              <button onClick={addTask} className="bg-blue-500 flex-1 py-2 rounded">Add</button>
              <button onClick={()=>setShowAddModal(false)} className="bg-red-500 flex-1 py-2 rounded">Cancel</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
</script>
